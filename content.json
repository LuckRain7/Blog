{"meta":{"title":"震雨的个人网站","subtitle":"For Future, For Freedom.","description":"想法，随笔，思考，感叹，瞬间，笔记...","author":"LuckRain7震雨","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2020-04-16T05:13:34.511Z","updated":"2020-04-16T05:13:34.511Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Document console.log(1111)"},{"title":"关于","date":"2020-04-16T05:31:30.425Z","updated":"2020-04-16T05:31:30.425Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我 / About Me你好 (^v^) 我是LuckRain7，你也可以叫我 震雨 我是一名在校前端学习者 爱好滑板、编程… 关于内容 / About The Website版权声明: 「署名-非商业性使用-相同方式共享 4.0 国际」（CC BY-NC-SA 4.0 协议） 所有文章非特别说明皆为原创。 社交信息 / Social Links Github： @luckrain7 Social： 新浪微博 | 知乎 | 掘金 | SegmentFault 思否 | 简书 | CSDN | 博客园 | 开源中国 E-mail： luckrain7@foxmail.com Old Blog： https://blog.rain7.top - VuePress 微信公众号：RainCode"},{"title":"所有分类","date":"2020-04-16T08:57:35.703Z","updated":"2020-04-16T08:57:35.703Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"归档","date":"2020-04-16T08:56:42.640Z","updated":"2020-04-16T08:56:42.640Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2020-04-16T08:17:35.593Z","updated":"2020-04-16T08:17:35.593Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"玩转 GitHub 的几个小技巧","slug":"play-github-good","date":"2020-04-29T05:08:10.000Z","updated":"2020-04-29T05:18:11.212Z","comments":true,"path":"2020/04/29/play-github-good/","link":"","permalink":"http://yoursite.com/2020/04/29/play-github-good/","excerpt":"","text":"1. GitHub 搜索技巧在项目名称搜索 in:name xxx 在项目描述搜索 in:description xxx 在项目 README 搜索 in:readme xxx 利用 star 搜索 stars:&gt;3000 xxx 利用 fork 搜索 forks:&gt;300 xxx 也可以直接使用 GitHub 高级搜索页面 https://github.com/search/advanced 2. 轻松浏览文件和目录Octotree 浏览器插件，可以帮助您浏览目录，并使用熟悉的树状结构打开文件。 地址：谷歌商店网址(需要稳定的网络环境) | GitHub 下方图片来源 https://github.com/ovity/octotree (Octotree 官方文档) 3. Markdown技巧3.1 键盘标签 可以使用 &lt;kbd&gt; 标签进行包裹，会使文本看起来像按钮 1&lt;kbd&gt;Q&lt;&#x2F;kbd&gt; | &lt;kbd&gt;W&lt;&#x2F;kbd&gt; | &lt;kbd&gt;E&lt;&#x2F;kbd&gt; | &lt;kbd&gt;R&lt;&#x2F;kbd&gt; 3.2 差异可视化 可以使用反引号可视化差异，并diff根据需要突出显示红色或绿色的线。 ​```diff box.onclick = fn.bind(obj, 200); box.onclick = fn.call(obj, 200);​``` 效果如下 12- box.onclick = fn.bind(obj, 200);+ box.onclick = fn.call(obj, 200); 3.3 折叠效果添加冗长的错误日志或冗长程序输出的问题可以解决的错误有帮助的，但如果它占用页的垂直空间，可以考虑使用&lt;details&gt;和&lt;summary&gt;标签。 12345678910111213141516171819202122Having some problems firing up the laser.&lt;details&gt;&lt;summary&gt;Click here to see terminal history + debug info&lt;&#x2F;summary&gt;&lt;pre&gt;488 cd &#x2F;opt&#x2F;LLL&#x2F;controller&#x2F;laser&#x2F;489 vi LLLSDLaserControl.c490 make491 make install492 &#x2F;images&#x2F;2020&#x2F;04&#x2F;29&#x2F;sanity_check493 &#x2F;images&#x2F;2020&#x2F;04&#x2F;29&#x2F;configure -o test.cfg494 vi test.cfg495 vi ~&#x2F;last_will_and_testament.txt496 cat &#x2F;proc&#x2F;meminfo497 ps -a -x -u498 kill -9 2207499 kill 2208500 ps -a -x -u501 touch &#x2F;opt&#x2F;LLL&#x2F;run&#x2F;ok502 LLLSDLaserControl -ok1&lt;&#x2F;pre&gt;&lt;details&gt; 效果如下： Click here to see terminal history + debug info 488 cd /opt/LLL/controller/laser/ 489 vi LLLSDLaserControl.c 490 make 491 make install 492 /images/2020/04/29/sanity_check 493 /images/2020/04/29/configure -o test.cfg 494 vi test.cfg 495 vi ~/last_will_and_testament.txt 496 cat /proc/meminfo 497 ps -a -x -u 498 kill -9 2207 499 kill 2208 500 ps -a -x -u 501 touch /opt/LLL/run/ok 502 LLLSDLaserControl -ok1 3.4 使文字和图像居中在 MarkDown 中直接是使用居中DIV 1234&lt;div align&#x3D;&quot;center&quot;&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;rain7.top&#x2F;luckrain7.png&quot; width&#x3D;&quot;350&quot;&gt;&lt;p&gt;This is RainCode&lt;&#x2F;p&gt;&lt;&#x2F;div&gt; 效果如下： This is RainCode 3.5 较小的文字 在&lt;sup&gt;或&lt;sub&gt;标记中换行以使其变小。非常适合在图像下添加“图1：描述”之类的内容，或者使表中的文本变小以使其不会水平滚动。 1234&lt;div align&#x3D;&quot;center&quot;&gt;&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;rain7.top&#x2F;luckrain7.png&quot; width&#x3D;&quot;350&quot;&gt;&lt;br&gt;&lt;sup&gt;&lt;strong&gt;Fig 1:&lt;&#x2F;strong&gt; luckrain7&#39;s logo&lt;&#x2F;sup&gt;&lt;&#x2F;div&gt; 效果如下： Fig 1: luckrain7's logo 4.徽标制作下面教程是简单的常规用法 1.首先登陆网站： https://shields.io/ 2.向下滑动，找到 Static 功能标题，如图进行制作 3.页面会跳转到制作好的徽标页面，右击点击徽标(SVG格式)保存到本地 4.使用 123将图片上传到自己的图床中或仅本地使用使用图片嵌套格式使用[![](&#x2F;images&#x2F;2020&#x2F;04&#x2F;29&#x2F;RainCode.svg)](https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;-kBwis0MhRNgVEtDF7wPYA) 5. 修改仓库语言项目仓库是根据根目录下的文件类型进行判断，哪种类型多，仓库就在仓库列表界面显示哪种语言类型 修改步骤： 1.在项目中添加文件 .gitattributes 2.输入以下内容（重置识别类型）： 1234567*.[扩展名] linguist-language&#x3D;[将此文件识别为哪种语言]# 我这以vue为例*.js linguist-language&#x3D;vue*.css linguist-language&#x3D;vue*.html linguist-language&#x3D;vue*.sh linguist-language&#x3D;vue 这样项目仓库语言会被修改为 vue 参考文章：https://github.blog/2020-04-09-github-protips-tips-tricks-hacks-and-secrets-from-lee-reilly/ 推荐阅读： 一道关于JavaScript 代码执行顺序的面试题解析 如何在 Array.forEach 中正确使用 async 如何在 Array.filter 中正确使用 async 如何在 Array.reduce 中正确使用 async 如何在 Array.map 中正确使用 async 一道“简单”的This题解析 如果对你有所帮助，可以点赞、收藏。","categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/categories/GitHub/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]},{"title":"在 Array.some 中正确使用 async","slug":"async-in-Array.some","date":"2020-04-24T01:48:22.000Z","updated":"2020-04-23T14:30:42.248Z","comments":true,"path":"2020/04/24/async-in-Array.some/","link":"","permalink":"http://yoursite.com/2020/04/24/async-in-Array.some/","excerpt":"","text":"使用 Promise 检查集合 本文译自：How to use async functions with Array.some and every in Javascript - 在第一篇文章中， 我们介绍了async / await 如何帮助执行异步命令 ，但是在异步处理集合时却无济于事。在这篇文章中，当结果为布尔值时，我们将研究 some 和 every 函数用于更有效的 reduce 1. some 和 every 函数这些函数与filter一样，获得递归函数，但是它们根据断言函数是否返回特定值而返回单个 true / false。对于some，如果任何断言函数返回 true，则结果为true。对于该every函数，如果返回任何false，则结果将为false。 123456789101112131415const arr = [1, 2, 3];const someRes = arr.some((i) =&gt; &#123; return i % 2 === 0;&#125;);console.log(someRes);// trueconst everyRes = arr.every((i) =&gt; &#123; return i &lt; 2;&#125;);console.log(everyRes);// false 2. 异步 some/every2.1 使用异步 filter仅考虑结果，可以使用 async 来模拟这些函数filter，在上一篇文章中已经介绍了如何将其转换为async。 123456789// syncconst some = (arr, predicate) =&gt; arr.filter(predicate).length &gt; 0;const every = (arr, predicate) =&gt; arr.filter(predicate).length === arr.length;// asyncconst asyncSome = async (arr, predicate) =&gt; (await asyncFilter(arr, predicate)).length &gt; 0;const asyncEvery = async (arr, predicate) =&gt; (await asyncFilter(arr, predicate)).length === arr.length; 短路（Short-circuiting）但是，内置的some/ every函数和filter的实现之间存在重要的区别。当有一个元素为时返回true时，some将短路并且不处理其余元素： 123456789101112const arr = [1, 2, 3];const res = arr.some((i) =&gt; &#123; console.log(`Checking $&#123;i&#125;`); return i % 2 === 0;&#125;);// Checking 1// Checking 2console.log(res);// true 同样，every在第一个错误结果之后停止： 123456789101112const arr = [1, 2, 3];const res = arr.every((i) =&gt; &#123; console.log(`Checking $&#123;i&#125;`); return i &lt; 2;&#125;);// Checking 1// Checking 2console.log(res);// false 让我们看看如何编写一个异步版本，该版本以类似的方式工作并且工作量最少！ 2.2 异步 some最好的解决方案是使用异步进行迭代，并在找到结果为 true 后立即返回： 12345678910111213141516171819const arr = [1, 2, 3];const asyncSome = async (arr, predicate) =&gt; &#123; for (let e of arr) &#123; if (await predicate(e)) return true; &#125; return false;&#125;;const res = await asyncSome(arr, async (i) =&gt; &#123; console.log(`Checking $&#123;i&#125;`); await sleep(10); return i % 2 === 0;&#125;);// Checking 1// Checking 2console.log(res);// true 对于第一个元素predicate(e)返回结果为 true，它结束了for循环。 2.3 异步 every类似的结构适用于every，这只是对条件求反的问题： 12345678910111213141516171819const arr = [1, 2, 3];const asyncEvery = async (arr, predicate) =&gt; &#123; for (let e of arr) &#123; if (!await predicate(e)) return false; &#125; return true;&#125;;const res = await asyncEvery(arr, async (i) =&gt; &#123; console.log(`Checking $&#123;i&#125;`); await sleep(10); return i &lt; 2;&#125;);// Checking 1// Checking 2console.log(res);// false 只要predicate(e)返回false，函数便会终止而不检查其他元素。 2.4 并行处理短路（ short-circuiting ）实现顺序地处理元素，这在资源使用方面很有效，但可能导致执行时间更长。 例如，如果通过递归发送网络请求，则一次发送一个请求可能会花费一些时间。另一方面，虽然这可能导致发送更多的请求，但同时发送所有请求会更快。 3. 结论some和every功能很接近异步filter，但要严格遵循同步规范，异步for循环是一个更好的选择。 推荐阅读 如何在 Array.forEach 中正确使用 async 如何在 Array.filter 中正确使用 async 如何在 Array.reduce 中正确使用 async 如何在 Array.map 中正确使用 async","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"async","slug":"async","permalink":"http://yoursite.com/tags/async/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"如何正确的在 Array.map 使用 async","slug":"async-in-Array.map","date":"2020-04-22T02:46:46.000Z","updated":"2020-04-22T02:55:34.393Z","comments":true,"path":"2020/04/22/async-in-Array.map/","link":"","permalink":"http://yoursite.com/2020/04/22/async-in-Array.map/","excerpt":"","text":"在 map 中返回Promises，然后等待结果 本文译自How to use async functions with Array.map in Javascript - Tamás Sallai 。 在前面的文章中，我们介绍了 async / await如何帮助执行异步命令 ，但在异步处理集合时却无济于事。在本文中，我们将研究该map函数，该函数是最常用的函数，它将数据从一种形式转换为另一种形式（这里可以理解为 map具有返回值）。 1. Array.map该map是最简单和最常见的采集功能。它通过迭代函数运行每个元素，并返回包含结果的数组。 向每个元素添加一的同步版本： 12345678const arr = [1, 2, 3];const syncRes = arr.map((i) =&gt; &#123; return i + 1;&#125;);console.log(syncRes);// 2,3,4 异步版本需要做两件事。首先，它需要将每个项目映射到具有新值的 Promise，这是async在函数执行之前添加的内容。 其次，它需要等待所有Promises，然后将结果收集到Array中。幸运的是，Promise.all内置调用正是我们执行步骤2所需的。 这使得一个异步的一般模式map是Promise.all(arr.map(async (...) =&gt; ...))。 异步实现与同步实现相同： 123456789const arr = [1, 2, 3];const asyncRes = await Promise.all(arr.map(async (i) =&gt; &#123; await sleep(10); return i + 1;&#125;));console.log(asyncRes);// 2,3,4 2. 并发上面的实现为数组的每个元素并行运行迭代函数。通常这很好，但是在某些情况下，它可能会消耗过多的资源。当异步函数访问 API 或消耗过多的RAM以至于无法一次运行太多RAM时，可能会发生这种情况。 尽管异步map易于编写，但要增加并发控件。在接下来的几个示例中，我们将研究不同的解决方案。 2.1 批量处理最简单的方法是对元素进行分组并逐个处理。这使您可以控制一次可以运行的最大并行任务数。但是由于一组必须在下一组开始之前完成，因此每组中最慢的元素成为限制因素。 为了进行分组，下面的示例使用Underscore.js的groupBy实现。许多库提供了一种实现，并且它们大多数都是可互换的。Lodash是个例外，因为其 groupBy 不传递 item的索引。 如果您不熟悉groupBy，它将通过迭代函数运行每个元素，并返回一个对象，其键为结果，值为产生该值的元素的列表。 为了使群体最多n的元素，一个迭代器 Math.floor(i / n)，其中 i 是元素的索引。例如，一组大小为3的元素将映射以下元素： 123456780 &#x3D;&gt; 01 &#x3D;&gt; 02 &#x3D;&gt; 03 &#x3D;&gt; 14 &#x3D;&gt; 15 &#x3D;&gt; 16 &#x3D;&gt; 2... Javascript实现： 12345678910const arr = [30, 10, 20, 20, 15, 20, 10];console.log( _.groupBy(arr, (_v, i) =&gt; Math.floor(i / 3)));// &#123;// 0: [30, 10, 20],// 1: [20, 15, 20],// 2: [10]// &#125; 最后一组可能比其他组小，但是保证所有组都不会超过最大组大小。 要映射一组，通常的Promise.all(group.map(...))构造是很好。 要按顺序映射组，我们需要一个reduce，它将先前的结果（memo）与当前组的结果连接起来： 12345return Object.values(groups) .reduce(async (memo, group) =&gt; [ ...(await memo), ...(await Promise.all(group.map(iteratee))) ], []); 此实现基于以下事实：await memo等待上一个结果的完成才进行下一个任务。 实现批处理的完整实现： 123456789101112131415161718192021222324252627282930313233343536373839const arr = [30, 10, 20, 20, 15, 20, 10];const mapInGroups = (arr, iteratee, groupSize) =&gt; &#123; const groups = _.groupBy(arr, (_v, i) =&gt; Math.floor(i / groupSize)); return Object.values(groups) .reduce(async (memo, group) =&gt; [ ...(await memo), ...(await Promise.all(group.map(iteratee))) ], []);&#125;;const res = await mapInGroups(arr, async (v) =&gt; &#123; console.log(`S $&#123;v&#125;`); await sleep(v); console.log(`F $&#123;v&#125;`); return v + 1;&#125;, 3);// -- first batch --// S 30// S 10// S 20// F 10// F 20// F 30// -- second batch --// S 20// S 15// S 20// F 15// F 20// F 20// -- third batch --// S 10// F 10console.log(res);// 31,11,21,21,16,21,11 2.2 并行处理并发控制的另一种类型是并行执行大多数n任务，并在完成一项任务时启动一个新任务。 我无法为此提供一个简单的实现，但是幸运的是，Bluebird提供了一个开箱即用的库。这很简单，只需导入库并使用Promise.map支持该concurrency选项的功能即可。 在下面的示例中，并发限制为2，这意味着立即启动2个任务，然后每完成一个任务，就开始一个新任务，直到没有剩余： 123456789101112131415161718192021222324252627const arr = [30, 10, 20, 20, 15, 20, 10];// Bluebird promiseconst res = await Promise.map(arr, async (v) =&gt; &#123; console.log(`S $&#123;v&#125;`) await sleep(v); console.log(`F $&#123;v&#125;`); return v + 1;&#125;, &#123;concurrency: 2&#125;);// S 30// S 10// F 10// S 10// F 30// S 20// F 10// S 15// F 20// S 20// F 15// S 20// F 20// F 20console.log(res);// 31,11,21,21,16,21,11 2.3 顺序处理有时，并发太多，因此应该一个接一个地处理元素。 一个简单的实现是使用并发性为 1 的 Bluebird 的 Promise。但是在这种情况下，它不保证包括一个库，因为reduce这样做很简单： 12345678910111213141516171819const arr = [1, 2, 3];const res = await arr.reduce(async (memo, v) =&gt; &#123; const results = await memo; console.log(`S $&#123;v&#125;`) await sleep(10); console.log(`F $&#123;v&#125;`); return [...results, v + 1];&#125;, []);// S 1// F 1// S 2// F 2// S 3// F 3console.log(res);// 2,3,4 确保在执行任何其他操作之前 await memo，因为如果没有 await，它仍然会并发运行！ 3. 结论该map功能很容易转换为异步，因为Promise.all内置功能繁重。但是控制并发需要一些计划。 推荐阅读 如何在 Vue 中优雅的使用防抖节流 如何在 Array.forEach 中正确使用 async 如何在 Array.filter 中正确使用 async 如何在 Array.reduce 中正确使用 async 如果对你有所帮助，可以点赞、收藏。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"async","slug":"async","permalink":"http://yoursite.com/tags/async/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"一道关于JavaScript 代码执行顺序的面试题解析","slug":"javascript-execution-order","date":"2020-04-20T04:00:00.000Z","updated":"2020-04-20T04:02:12.355Z","comments":true,"path":"2020/04/20/javascript-execution-order/","link":"","permalink":"http://yoursite.com/2020/04/20/javascript-execution-order/","excerpt":"","text":"0. 引言：最近写了一些异步递归的代码，着实有点头疼，索性重新研究一下JavaScript 代码执行顺序，并附上一道面试题的解析。 1. JavaScript 代码执行顺序 首先我们了解几个概念 1.1 微任务/宏任务异步队列中包括：微任务（micro-task） 和 宏任务（macro-task） 微任务包括： process.nextTick ，Promise （ process.nextTick 为 Node 独有） 宏任务包括： script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering Tips： 微任务优先级高于宏任务的前提是：同步代码已经执行完成。因为 script 属于宏任务，程序开始后会首先执行同步脚本，也就是script 。 Promise 里边的代码属于同步代码，.then() 中执行的代码才属于异步代码。 1.2 Event Loop（事件轮询）Event Loop 是一个程序结构，用于等待和发送消息和事件。 Event Loop 执行顺序如下所示： 首先执行同步代码（宏任务） 当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行 执行所有微任务 当执行完所有微任务后，如有必要会渲染页面 然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数 Tips：简化讲：先执行一个宏任务（script同步代码），然后执行并清空微任务，再执行一个宏任务，然后执行并清空微任务，再执行一个宏任务，再然后执行并清空微任务……如此循环往复（一个宏任务 -&gt; 清空微任务 -&gt; 一个宏任务 -&gt; 清空微任务） 2. 面试题详解2.1 题目1234567891011121314151617181920212223242526272829303132setTimeout(function () &#123; console.log(\" set1\"); new Promise(function (resolve) &#123; resolve(); &#125;).then(function () &#123; new Promise(function (resolve) &#123; resolve(); &#125;).then(function () &#123; console.log(\"then4\"); &#125;); console.log(\"then2 \"); &#125;);&#125;);new Promise(function (resolve) &#123; console.log(\"pr1\"); resolve();&#125;).then(function () &#123; console.log(\"then1\");&#125;);setTimeout(function () &#123; console.log(\"set2\");&#125;);console.log(2);new Promise(function (resolve) &#123; resolve();&#125;).then(function () &#123; console.log(\"then3\");&#125;); 2.2 执行过程解析执行所有同步代码（第一次宏任务）： 12345678910111213141516171819202122232425262728293031323334353637setTimeout(function () &#123; // setTimeout 内 function 放入宏任务 console.log(\" set1\"); new Promise(function (resolve) &#123; resolve(); &#125;).then(function () &#123; new Promise(function (resolve) &#123; resolve(); &#125;).then(function () &#123; console.log(\"then4\"); &#125;); console.log(\"then2 \"); &#125;);&#125;);new Promise(function (resolve) &#123; console.log(\"pr1\"); // Promise里边的代码直接执行 打印 pr1 resolve();&#125;).then(function () &#123; console.log(\"then1\"); // Promise.then 放入微任务&#125;);setTimeout(function () &#123; console.log(\"set2\"); // setTimeout内function 放入宏任务&#125;);console.log(2); // 打印 2new Promise(function (resolve) &#123; resolve();&#125;).then(function () &#123; console.log(\"then3\"); //Promise.then 放入微任务&#125;);// 此时控制台打印 ： pr1 &gt; 2// 异步任务队列：[微任务数:2][宏任务数：2]// 执行并清空微任务 执行并清空微任务 1234567891011function () &#123; console.log(\"then1\"); // 输出 then1&#125;function () &#123; console.log(\"then3\"); // 输出 then3&#125;// 此时控制台打印 ： then1 &gt; then3// 异步任务：[微任务数:0][宏任务数：2]// 执行一个宏任务 执行一个宏任务 1234567891011121314151617function () &#123; console.log(\" set1\"); //打印 set1 new Promise(function (resolve) &#123; resolve(); &#125;).then(function () &#123; // Promise.then 放入微任务 new Promise(function (resolve) &#123; resolve(); &#125;).then(function () &#123; console.log(\"then4\"); &#125;); console.log(\"then2 \"); &#125;);&#125;// 此时控制台打印 ： set1// 异步任务：[微任务数:1][宏任务数：1]// 执行并清空微任务 执行并清空微任务 123456789101112function () &#123; new Promise(function (resolve) &#123; resolve(); &#125;).then(function () &#123; console.log(\"then4\"); // Promise.then 放入微任务 &#125;); console.log(\"then2 \"); // 打印 then2&#125;// 此时控制台打印 ： then2// 异步任务：[微任务数:1][宏任务数：1]// 此时微任务列表增加并未清空，继续执行微任务 此时微任务列表增加并未清空，继续执行微任务 1234567function () &#123; console.log(\"then4\"); // 打印 then4&#125;// 此时控制台打印 ： then4// 异步任务：[微任务数:0][宏任务数：1]// 执行宏任务 执行宏任务 123456function () &#123; console.log(\"set2\"); // 打印 set2&#125;// 此时控制台打印 ： set2// 异步任务：[微任务数:0][宏任务数：0]// 程序结束 完整输入顺序 12345678pr12then1then3set1then2 then4set2 推荐阅读 一道“简单”的 This 题解析 如何在Vue中优雅的使用防抖、节流 如何在 Array.forEach 中正确使用 Async 如何在 Array.filter 中正确使用 Async 如何在 Array.reduce 中正确使用 async","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"Git 常用命令及应用这一篇就够了（新手向）","slug":"git-use","date":"2020-04-17T01:00:22.000Z","updated":"2020-04-17T01:29:39.941Z","comments":true,"path":"2020/04/17/git-use/","link":"","permalink":"http://yoursite.com/2020/04/17/git-use/","excerpt":"","text":"1. git 常用命令1.1 常用命令1234567891011121314151617181920212223242526272829303132333435363738394041424344# 初始化gitgit init # 克隆项目git clone [url] # 显示文件状态git status -s # 添加文件到暂存区git add . #添加所有文件到暂存区git add [文件名] #添加指定文件到暂存区# 提交暂存区到仓库区git commit -m [提交信息] # 拉取远程仓库的变化，更新本地分支git pull # 推送到远程仓库git push git push [远程主机名] [本地分支名]# 更新所有的远程仓库信息git fetch --all # 合并指定分支到当前分支git merge [分支名] # 分支相关git branch # 列出所有本地分支git checkout [分支名] # 切换到指定分支git checkout -b [本地分支名] origin/[远程分支名] # 拉取远程分支#查看项目中git配置git config --list# 配置全局信息git config --global user.name \"[name]\"git config --global user.email \"[email address]\"# 项目中配置git config user.name \"[name]\"git config user.email \"[email address]\" 1.2 git remote 管理远程仓库 1234567891011121314#查看远程仓库git remote #查看关联的远程仓库的详细信息git remote -v #添加远程仓库的关联git remote add origin [远程仓库地址] #删除远程仓库的关联git remote remove [远程仓库名称] #更新远程仓库的分支git remote update origin --prune 1.3 git rebase rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 个人感觉非特定情况，还是不建议使用 2. Git的常见应用2.1 本地项目上传至多个远程库1234567891011# 添加关联远程库(这里以github和码云为例，大家替换掉仓库地址即可)git remote add gitee [url]git remote add gitee git@gitee.com:LuckRain/Knowledge-Sharing.gitgit remote add github git@github.com:LuckRain7/Knowledge-Sharing.git# 推送时分别将master分支推送到关联远程库git push gitee mastergit push github master# 删除关联远程库git remote rm [origin] 2.2 Git 远程分支强制覆盖本地分支 需在需要覆盖的分支上进行一下操作 12345678# 更新所有的远程仓库信息git fetch --all # 强制重置为 origin/master（可以换成你需要的远程分支） 远程分支git reset --hard [origin/master] # 拉取最新代码git pull 2.3 Git 配置忽略规则(.gitignore）不生效解决方案 清除缓存 重新提交 1234567891011# 清除缓存git rm -r --cached .# 将所有文件添加到缓存区git add . # 添加提交信息git commit -m 'update .gitignore' # 强制覆盖 以远程分支 rain 为例git push 2.4 Git 强制提交本地分支覆盖远程分支12345678# 将所有文件添加到缓存区git add .# 添加提交信息git commit -m '更新信息'# 强制覆盖 以远程分支 rain 为例git push origin rain --force 2.5 分支合并2.5.1 情景：我现在的分支是 rain 我要把别人的分支 snow 合并到我的分支上来 2.5.2 操作： 首先要进行切换分支（切换分支前要保证自己分支的内容都已经提交了） 12345# 情况一:分支是本地分支(直接切换)git branch snow # 情况二:分支是远程分支(新建本地分支并与远程分支关联)git checkout -b snow origin/snow 在 snow 分支上拉取最新代码 1git pull 切换回我自己的分支rain 1git branch rain 执行合并 1git merge rain 处理代码冲突 我这里比较喜欢使用 VS Code 的可视化界面解决代码冲突 2.6 版本回溯123456#版本回退到上一个版本git reset --hard HEAD^ # 回溯到指定版本git log #查看git历史版本信息，并找到指定版本的commit idgit reset --hard [commitId] # 进行回溯 下图是 commitId 形式 2.7 同时配置gitee&amp;github(多平台)ssh2.7.1. 本地创建多个ssh1234567# 进入.ssh目录cd ~/.ssh# 生成sshssh-keygen -t rsa -C \"xxxx@email.com\" -f \"rain_github\" # 后续绑定github平台ssg-keygen -t rsa -C \"xxxx@email.com\" -f \"rain_gitee\" # 后续绑定gitee平台ssg-keygen -t rsa -C \"xxxx@email.com\" -f \"coding_id_rsa\" # 后续绑定coding平台 会在本地生成如下文件 2.7.2. 在各个平台进行ssh绑定2.7.2.1 github平台操作 2.7.2.2 gitee 平台操作 2.7.3. 解决ssh冲突配置在 C:\\Users\\ZHCZ\\.ssh 文件夹中新建 config 文件 进行如下配置 1234567891011121314151617# giteeHost gitee.comHostName gitee.comPreferredAuthentications publickeyIdentityFile C:\\Users\\ZHCZ\\.ssh\\rain_gitee# githubHost github.comHostName github.comPreferredAuthentications publickeyIdentityFile C:\\Users\\ZHCZ\\.ssh\\rain_github# codingHost e.coding.netHostName e.coding.netPreferredAuthentications publickeyIdentityFile C:\\Users\\ZHCZ\\.ssh\\coding_id_rsa 2.7.4. 测试12ssh -T git@gitee.comssh -T git@github.com 返回success则表示设置成功 推荐阅读 在 Array.reduce 中正确使用 async 如何在 Array.filter 中正确使用 Async 如何在 Array.forEach 中正确使用 Async 如何在 Vue中优雅的使用防抖节流","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}]},{"title":"在 Array.reduce 中正确使用 async","slug":"async-in-Array.reduce","date":"2020-04-15T04:48:22.000Z","updated":"2020-04-23T14:30:44.946Z","comments":true,"path":"2020/04/15/async-in-Array.reduce/","link":"","permalink":"http://yoursite.com/2020/04/15/async-in-Array.reduce/","excerpt":"","text":"如何使用带有reduce的Promise以及如何在串行和并行处理之间进行选择 本文译自How to use async functions with Array.reduce in Javascript - Tamás Sallai 。 在第一篇文章中，我们介绍了async / await 如何帮助执行异步命令，但在异步处理集合时却无济于事。在本文中，我们将研究reduce函数，它是功能最丰富的集合函数，因为它可以模拟所有其他函数。 1. Array.reduceReduce迭代地构造一个值并返回它，它不一定是一个集合。这就是名字的来源，因为它减少了收集到的值。 迭代函数获取先前的结果（ memo在下面的示例中调用）以及当前值e。 以下函数对元素进行求和，从0开始（第二个参数reduce）： 12345678const arr = [1, 2, 3];const syncRes = arr.reduce((memo, e) =&gt; &#123; return memo + e;&#125;, 0);console.log(syncRes);// 6 memo e 结果 0（初始） 1个 1个 1个 2 3 3 3 （最终结果）6 2. 异步 reduce异步版本几乎相同，但每次迭代都会返回一个Promise，因此 memo 将是先前结果的Promise。迭代函数需要 await 它才能计算下一个结果： 123456789101112// utility function for sleepingconst sleep = (n) =&gt; new Promise((res) =&gt; setTimeout(res, n));const arr = [1, 2, 3];const asyncRes = await arr.reduce(async (memo, e) =&gt; &#123; await sleep(10); return (await memo) + e;&#125;, 0);console.log(asyncRes);// 6 memo e 结果 0（初始） 1 Promise (1) Promise (1) 2 Promise (3) Promise (3) 3 （最终结果）Promise (6) 使用的结构async (memo, e) =&gt; await memo，reduce可以处理任何异步功能，并且可以对其进行await编辑。 3. 定时当在 reduce 中并发时有一个有趣的属性。在同步版本中，元素被一对一处理，这并不奇怪，因为它们依赖于先前的结果。但是，当异步 reduce 运行时，所有迭代函数将开始并行运行，await memo仅在需要时才等待上一个结果。 3.1 await memo last在上面的示例中，所有 sleep 并行执行 ，因为await memo使得函数等待上一个函数完成后执行。 1234567891011const arr = [1, 2, 3];const startTime = new Date().getTime();const asyncRes = await arr.reduce(async (memo, e) =&gt; &#123; await sleep(10); return (await memo) + e;&#125;, 0);console.log(`Took $&#123;new Date().getTime() - startTime&#125; ms`);// Took 11-13 ms 3.2 await memo first但是当await memo最先出现时，这些函数按顺序运行： 123456789101112const arr = [1, 2, 3];const startTime = new Date().getTime();const asyncRes = await arr.reduce(async (memo, e) =&gt; &#123; await memo; await sleep(10); return (await memo) + e;&#125;, 0);console.log(`Took $&#123;new Date().getTime() - startTime&#125; ms`);// Took 36-38 ms 这种行为通常不是问题，这意味着不依赖于先前结果的所有内容都将立即被计算出来，只有依赖部分正在等待先前的值。 3.3 当并行很重要时但是在某些情况下，提前做一些事情可能是不可行的。 例如，我有一段代码可以打印不同的PDF，并使用 pdf-lib 库将它们拼接到一个文件中。 实现 printPDF 并行运行资源密集型功能： 1234567891011const result = await printingPages.reduce(async (memo, page) =&gt; &#123; const pdf = await PDFDocument.load(await printPDF(page)); const pdfDoc = await memo; (await pdfDoc.copyPages(pdf, pdf.getPageIndices())) .forEach((page) =&gt; pdfDoc.addPage(page)); return pdfDoc;&#125;, PDFDocument.create()); 我注意到当我有很多页面要打印时，它将占用过多的内存并减慢整个过程。 一个简单的更改，使 printPDF 调用等待上一个调用完成： 1234567891011const result = await printingPages.reduce(async (memo, page) =&gt; &#123; const pdfDoc = await memo; const pdf = await PDFDocument.load(await printPDF(page)); (await pdfDoc.copyPages(pdf, pdf.getPageIndices())) .forEach((page) =&gt; pdfDoc.addPage(page)); return pdfDoc;&#125;, PDFDocument.create()); 4. 结论reduce 函数很容易转换为异步函数，但是要弄清楚并行性可能很棘手。幸运的是，它很少破坏任何东西，但是在一些资源密集型或速率受限的操作中，了解如何调用函数至关重要。 推荐阅读 如何在 Array.forEach 中正确使用 Async 如何在 Array.filter 中正确使用 Async","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"async","slug":"async","permalink":"http://yoursite.com/tags/async/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"在 Array.filter 中正确使用 Async","slug":"async-in-Array.filter","date":"2020-04-13T04:17:22.000Z","updated":"2020-04-16T08:16:26.573Z","comments":true,"path":"2020/04/13/async-in-Array.filter/","link":"","permalink":"http://yoursite.com/2020/04/13/async-in-Array.filter/","excerpt":"","text":"本文译自How to use async functions with Array.filter in Javascript - Tamás Sallai 。 0. 如何仅保留满足异步条件的元素在第一篇文章中，我们介绍了 async / await 如何帮助处理异步事件，但在异步处理集合时却无济于事。在本文中，我们将研究该filter函数，它可能是支持异步函数的最直观的方法。 1. Array.filter该filter函数仅保留通过条件的元素。它得到一个断言( predicate )函数，并且此函数返回 true / false 值。结果集合仅包含断言( predicate )返回 true 的元素。 12345678const arr = [1, 2, 3, 4, 5];const syncRes = arr.filter((i) =&gt; &#123; return i % 2 === 0;&#125;);console.log(syncRes);// 2,4 2. filter 结合 map 使用这次的异步版本要复杂一些，它分为两个阶段。第一个通过断言函数异步地映射数组，从而生成true / false 值。然后第二步是利用第一步的结果同步 filter 123456789101112131415const arr = [1, 2, 3, 4, 5];const asyncFilter = async (arr, predicate) =&gt; &#123; const results = await Promise.all(arr.map(predicate)); return arr.filter((_v, index) =&gt; results[index]);&#125;const asyncRes = await asyncFilter(arr, async (i) =&gt; &#123; await sleep(10); return i % 2 === 0;&#125;);console.log(asyncRes);// 2,4 或单行实现： 12const asyncFilter = async (arr, predicate) =&gt; Promise.all(arr.map(predicate)) .then((results) =&gt; arr.filter((_v, index) =&gt; results[index])); 并发上面的实现同时运行所有断言函数。通常，这很好，但是与所有其他功能一样，它可能会使某些资源变得过分紧张。幸运的是，由于上述实现依赖于此 map，因此可以使用相同的并发控件。 4. filter 结合 reduce 使用除了使用异步 map 与同步之外 filter ，异步 reduce 也可以完成这项工作。由于它只是一个功能，因此即使没有提供相同级别的控制，结构也更加容易。 首先，从一个空数组（[]）开始。然后通过断言函数运行下一个元素，如果通过则将其追加到数组。如果没有，请跳过它。 12345// concurrentlyconst asyncFilter = async (arr, predicate) =&gt; arr.reduce(async (memo, e) =&gt; await predicate(e) ? [...await memo, e] : memo , []); 请注意，await predicate(e) 在 await memo 之前，这意味着这些将并行调用。 顺序处理要在调用下一个谓词函数之前等待其结束，请更改 await 的顺序： 12345// sequentiallyconst asyncFilter = async (arr, predicate) =&gt; arr.reduce(async (memo, e) =&gt; [...await memo, ...await predicate(e) ? [e] : []] , []); 此实现等待上一个元素，然后根据断言（...[e]或...[]）的结果有条件地附加一个元素。 5. 结论虽然异步filter是可能的，但它最初的工作方式看起来很奇怪。尽管并发控制仍然可用，但与其他异步功能相比，它们需要更多的计划去控制它。 推荐阅读 如何在 Array.forEach 中正确使用 Async 如何在 Vue中优雅的使用防抖节流","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"async","slug":"async","permalink":"http://yoursite.com/tags/async/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"在 Array.forEach 中正确使用 Async","slug":"async-in-Array.forEach","date":"2020-04-10T08:12:22.000Z","updated":"2020-04-16T08:16:22.339Z","comments":true,"path":"2020/04/10/async-in-Array.forEach/","link":"","permalink":"http://yoursite.com/2020/04/10/async-in-Array.forEach/","excerpt":"","text":"本文译自How to use async functions with Array.forEach in Javascript - Tamás Sallai 。 0. 如何异步遍历元素在第一篇文章中，我们介绍了 async / await 如何帮助处理异步事件，但在异步处理集合时却无济于事。在本文中，我们将研究该forEach功能，当您需要为集合中的每个元素运行一段代码时，该功能将非常有用。 1. forEach该forEach函数类似于map，但是它不转换值并使用结果，而是为每个元素运行该函数并丢弃结果（这里可以理解成是否有return值）。实际上，重要的部分是调用函数的副作用。 例如，将每个元素同步打印到控制台： 123456789101112const arr = [1, 2, 3];arr.forEach((i) =&gt; &#123; console.log(i);&#125;);// 1// 2// 3console.log(\"Finished sync\");// Finished sync 由于结果并不重要，因此可以使用异步函数作为迭代器： 1234567891011121314const arr = [1, 2, 3];arr.forEach(async (i) =&gt; &#123; // each element takes a different amount of time to complete await sleep(10 - i); console.log(i);&#125;);console.log(\"Finished async\");// Finished async// 3// 2// 1 2. 控制时间2.1 等待完成但是，并不奇怪，该函数被异步调用，并且程序执行超出了调用范围。这是与同步版本的重要区别，因为在执行下一行时，同步forEach已经完成，而异步版本尚未完成。这就是为什么“完成的异步”日志出现在元素之前的原因。 要在继续进行之前等待所有函数调用完成，可以使用带有Promise.all的map，并丢弃结果： 123456789101112131415const arr = [1, 2, 3];await Promise.all( arr.map(async (i) =&gt; &#123; await sleep(10 - i); console.log(i); &#125;));// 3// 2// 1console.log(\"Finished async\");// Finished async 进行此更改后，“完成的异步操作”排在最后。 2.2 顺序处理但是请注意，迭代函数是并行调用的。要忠实地遵循同步forEach，要先使用带await memo的reduce： 1234567891011121314const arr = [1, 2, 3];await arr.reduce(async (memo, i) =&gt; &#123; await memo; await sleep(10 - i); console.log(i);&#125;, undefined);// 1// 2// 3console.log(\"Finished async\");// Finished async 这样，元素依次依次处理，程序执行将等待整个数组完成后再继续。 3. 结论异步forEach易于使用，但是是否应使用forEach，map或 reduce取决于计时的要求。如果您只想在任何时候运行这些功能，请使用forEach。如果要确保继续操作之前完成操作，请使用map。最后，如果您需要一个一个地运行它们，请使用reduce。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"async","slug":"async","permalink":"http://yoursite.com/tags/async/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"如何在Vue中优雅的使用防抖节流","slug":"vue-debounce-throttle","date":"2020-04-09T10:40:00.000Z","updated":"2020-04-29T05:16:07.443Z","comments":true,"path":"2020/04/09/vue-debounce-throttle/","link":"","permalink":"http://yoursite.com/2020/04/09/vue-debounce-throttle/","excerpt":"","text":"1. 什么是防抖节流防抖：防止重复点击触发事件首先啥是抖？ 抖就是一哆嗦！原本点一下，现在点了 3 下！不知道老铁脑子是不是很有画面感！哈哈哈哈哈哈 典型应用就是防止用户多次重复点击请求数据。 代码实现要点：设置一个定时器，通过闭包，抓住定时器变量，控制定时器的添加和清除 直接上代码 123456789101112function debounce(fn, time) &#123; let _arguments = arguments; let timeout = null; return function () &#123; if (timeout) &#123; clearTimeout(timeout); &#125; timeout = setTimeout(() =&gt; &#123; fn.call(this, _arguments); &#125;, time); &#125;;&#125; 节流：指定时间间隔内只会执行一次任务大家都玩过 FPS 游戏吧（没玩过？？？打枪知道了吧！）道具的射速是一定的，不会因为你点击鼠标的速度加快而增加。 代码实现要点：通过一个布尔变量作为状态，判断代码是否需要执行 直接上代码 123456789101112function throttle(fn, time) &#123; let _arguments = arguments; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.call(this, _arguments); canRun = true; &#125;, time); &#125;;&#125; 2. 在 Vue 中优雅的使用我的应用场景：头像裁剪组件，对滚轮缩放后生成预览图片进行防抖处理 因为 Vue 组件中的 this 原因 1234methods:&#123; previewImageDebounce: Debounce(this.previewImage, 1000),&#125;//报错 Uncaught TypeError: Cannot read property 'previewImage' of undefined 我们要针对上面的防抖函数进行改造（函数内容 this 指向没问题，我们通过函数名调用函数） 1234567891011121314151617/* * description: 在vue中使用的防抖函数 * param fnName &#123;String&#125; 函数名 * param time &#123;Number&#125; 延迟时间 * return: 处理后的执行函数 */function VueDebounce(fnName, time) &#123; let timeout = null; return function () &#123; if (timeout) &#123; clearTimeout(timeout); &#125; timeout = setTimeout(() =&gt; &#123; this[fnName](); &#125;, time); &#125;;&#125; 在 Vue 组件中使用 1234567891011121314methods:&#123; /* 监听滚轮滑动 */ Wheel(ev) &#123; if (!this.newImage) return; // 判断放大和缩小 ev.deltaY &gt; 0 ? this.makeScaleChange(1) : this.makeScaleChange(0); // 预览图片 this.previewImageDebounce(); &#125;, /* 预览图片(防抖处理后) */ previewImageDebounce: VueDebounce(\"previewImage\", 1000), /* 预览图片 */ previewImage() &#123;......&#125;&#125; 这样的写法，算是很优雅了。节流就不在这里展开了，开动你的小脑袋不成问题。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"}]},{"title":"一道“简单”的 This 题解析","slug":"a-simple-this-question","date":"2020-04-07T11:40:22.000Z","updated":"2020-04-16T08:11:49.121Z","comments":true,"path":"2020/04/07/a-simple-this-question/","link":"","permalink":"http://yoursite.com/2020/04/07/a-simple-this-question/","excerpt":"","text":"1. 知识点匿名函数无法从函数内部应用自身 this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。 当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。 this 简单讲就是：调用我的”人”在什么上下文环境，我就指向谁！！ 2. 题目：123456789101112131415161718192021222324252627282930313233343536var number = 2;var obj = &#123; number: 4, fn1: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125;; &#125;)(), db2: function () &#123; this.number *= 2; &#125;,&#125;;var fn1 = obj.fn1;var fn2 = obj.db2;console.log(number);fn1();fn2();obj.fn1();obj.db2();console.log(window.number);console.log(obj.number); 3. 执行过程var fn1 = obj.fn1;fn1在全局执行，this 指向全局 1234567891011121314151617181920var number = 2;var obj = &#123; number: 4, fn1: (function () &#123; var number; this.number *= 2; // 指向全局变量number number=4 number = number * 2; number = 3; // 函数内number = 3 return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125;; &#125;)(), db2: function () &#123; this.number *= 2; &#125;,&#125;; var fn2 = obj.db2;fn2 中的 this 指向全局变量 console.log(number)打印全局变量 number 输出 ‘4’ fn1()this 指向全局 1234567891011121314151617181920var number = 2;var obj = &#123; number: 4, fn1: (function () &#123; var number; this.number *= 2; //全局number=4 number = number * 2; //NAN number = 3; //函数内number = 3 return function () &#123; var num = this.number; //全局作用域 num=4 this.number *= 2; // 全局number = 8 console.log(num); // 输出4 number *= 3; // 函数内number 3*3=9(形成闭包) console.log(number); // 输出9 &#125;; &#125;)(), db2: function () &#123; this.number *= 2; &#125;,&#125;; fn2()this 指向全局 1234567891011121314151617181920var number = 2;var obj = &#123; number: 4, fn1: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125;; &#125;)(), db2: function () &#123; this.number *= 2; //全局number = 8 8*2=16 &#125;,&#125;; obj.fn1()这里执行时 执行环境是 obj，所以 this 指向 obj this.number = obj.number number 则是形成闭包，调用上次的值 1234567891011121314151617181920var number = 2;var obj = &#123; number: 4, fn1: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; // obj.number=this.number=num=4 this.number *= 2; // obj.number =4*2=8 console.log(num); // 打印 num=4 number *= 3; //闭包 number=9*3=27 console.log(number); // 打印 number=27 &#125;; &#125;)(), db2: function () &#123; this.number *= 2; &#125;,&#125;; obj.db2()this 指向obj 1234567891011121314151617181920var number = 2;var obj = &#123; number: 4, fn1: (function () &#123; var number; this.number *= 2; number = number * 2; number = 3; return function () &#123; var num = this.number; this.number *= 2; console.log(num); number *= 3; console.log(number); &#125;; &#125;)(), db2: function () &#123; this.number *= 2; // obj.number=this.number=8*2=16 &#125;,&#125;; console.log(window.number)打印 16 console.log(obj.number)打印 16 参考链接 【THE LAST TIME】this：call、apply、bind 你不知道的 JavaSctript（上卷）","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"}],"tags":[{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"}]},{"title":"nuxt.js 究极按需引入 ant design vue","slug":"need-load-antdvue-in-muxt","date":"2020-04-06T13:45:00.000Z","updated":"2020-04-16T08:16:07.648Z","comments":true,"path":"2020/04/06/need-load-antdvue-in-muxt/","link":"","permalink":"http://yoursite.com/2020/04/06/need-load-antdvue-in-muxt/","excerpt":"","text":"在网络上看了很多ui组件按需加载的案例，但是那不是我想要的 1. 首先我们看一下 错误的示范！！1.1.配置插件 plugins\\antd-ui.js 1234567891011import Vue from 'vue'import Button from 'ant-design-vue/lib/button'import Steps from 'ant-design-vue/lib/steps'import Form from 'ant-design-vue/lib/form'import Input from 'ant-design-vue/lib/input'Vue.use(Button)Vue.use(Steps) // 步骤条Vue.use(Form)Vue.use(Form.Item)Vue.use(Input) 1.2.引入css样式 nuxt.config.js 1234567891011121314# nuxt.config.jsmodule.exports = &#123; css: [ './style/basic.less' 'ant-design-vue/lib/button/style/index.css', 'ant-design-vue/lib/steps/style/index.css', 'ant-design-vue/lib/form/style/index.css', 'ant-design-vue/lib/input/style/index.css' ], plugins: [&#123; src: '@/plugins/antd-ui', ssr: true &#125;], &#125; 不知道大家看出错什么问题 我们去官方文档中寻找一点线索 重点来喽！！！！！ css引入的样式是全局样式！！！如果这里是SPA，我觉着这OK，但是我们是SSR，需要进一步的优化 2. 真正的按需加载我们抛弃在全局样式中进行加载，在组件中引用 12345678910111213141516171819&lt;template&gt; &lt;div &gt; &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;import &#39;@&#x2F;node_modules&#x2F;ant-design-vue&#x2F;lib&#x2F;button&#x2F;style&#x2F;index.css&#39;import &#39;@&#x2F;node_modules&#x2F;ant-design-vue&#x2F;lib&#x2F;steps&#x2F;style&#x2F;index.css&#39;import &#39;@&#x2F;node_modules&#x2F;ant-design-vue&#x2F;lib&#x2F;form&#x2F;style&#x2F;index.css&#39;import &#39;@&#x2F;node_modules&#x2F;ant-design-vue&#x2F;lib&#x2F;input&#x2F;style&#x2F;index.css&#39;export default &#123; components: &#123;&#125;&#125;&lt;&#x2F;script&gt; &#125;&#125;&lt;&#x2F;style&gt; 虽然这样或许不是很优雅，但是这才是真正意义上的 SSR 按需加载 UI 组件","categories":[{"name":"Nuxt","slug":"Nuxt","permalink":"http://yoursite.com/categories/Nuxt/"}],"tags":[{"name":"Nuxt","slug":"Nuxt","permalink":"http://yoursite.com/tags/Nuxt/"}]}],"categories":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/categories/GitHub/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/categories/JavaScript/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/categories/Vue/"},{"name":"Nuxt","slug":"Nuxt","permalink":"http://yoursite.com/categories/Nuxt/"}],"tags":[{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"},{"name":"async","slug":"async","permalink":"http://yoursite.com/tags/async/"},{"name":"Array","slug":"Array","permalink":"http://yoursite.com/tags/Array/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"},{"name":"Vue","slug":"Vue","permalink":"http://yoursite.com/tags/Vue/"},{"name":"this","slug":"this","permalink":"http://yoursite.com/tags/this/"},{"name":"Nuxt","slug":"Nuxt","permalink":"http://yoursite.com/tags/Nuxt/"}]}