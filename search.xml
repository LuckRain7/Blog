<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>玩转 GitHub 的几个小技巧</title>
      <link href="/2020/04/29/play-github-good/"/>
      <url>/2020/04/29/play-github-good/</url>
      
        <content type="html"><![CDATA[<h2 id="1-GitHub-搜索技巧"><a href="#1-GitHub-搜索技巧" class="headerlink" title="1.  GitHub 搜索技巧"></a>1.  GitHub 搜索技巧</h2><p>在项目名称搜索 in:name xxx</p><p><img src="/images/2020/04/29/inname.png" alt="in:name xxx"></p><p>在项目描述搜索 in:description xxx</p><p><img src="/images/2020/04/29/indescription.png" alt=""></p><p>在项目 README 搜索 in:readme xxx</p><p><img src="/images/2020/04/29/inreadme.png" alt=""></p><p>利用 star 搜索 stars:&gt;3000 xxx </p><p><img src="/images/2020/04/29/instars.png" alt=""></p><p>利用 fork 搜索 forks:&gt;300 xxx</p><p><img src="/images/2020/04/29/inforks.png" alt=""></p><p>也可以直接使用 GitHub 高级搜索页面 <a href="https://github.com/search/advanced" target="_blank" rel="noopener"> https://github.com/search/advanced </a></p><p><img src="/images/2020/04/29/github-self-advanced-search.png" alt=""></p><h2 id="2-轻松浏览文件和目录"><a href="#2-轻松浏览文件和目录" class="headerlink" title="2.  轻松浏览文件和目录"></a>2.  轻松浏览文件和目录</h2><p>Octotree 浏览器插件，可以帮助您浏览目录，并使用熟悉的树状结构打开文件。</p><p>地址：<a href="https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc" target="_blank" rel="noopener">谷歌商店网址(需要稳定的网络环境)</a> | <a href="https://github.com/ovity/octotree" target="_blank" rel="noopener">GitHub</a></p><p>下方图片来源  <code>https://github.com/ovity/octotree (Octotree 官方文档)</code></p><p><img src="/images/2020/04/29/78818701-ee142700-7989-11ea-9297-c3cf4e88f891.gif" alt=""></p><h2 id="3-Markdown技巧"><a href="#3-Markdown技巧" class="headerlink" title="3.  Markdown技巧"></a>3.  Markdown技巧</h2><h3 id="3-1-键盘标签"><a href="#3-1-键盘标签" class="headerlink" title="3.1 键盘标签"></a>3.1 键盘标签</h3><blockquote><p>可以使用  <code>&lt;kbd&gt;</code> 标签进行包裹，会使文本看起来像按钮</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;kbd&gt;Q&lt;&#x2F;kbd&gt; |  &lt;kbd&gt;W&lt;&#x2F;kbd&gt;  | &lt;kbd&gt;E&lt;&#x2F;kbd&gt; |  &lt;kbd&gt;R&lt;&#x2F;kbd&gt;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/29/kbd.png" alt=""></p><h3 id="3-2-差异可视化"><a href="#3-2-差异可视化" class="headerlink" title="3.2 差异可视化"></a>3.2 差异可视化</h3><p> 可以使用反引号可视化差异，并<code>diff</code>根据需要突出显示红色或绿色的线。 </p><p>​```diff</p><ul><li>box.onclick = fn.bind(obj, 200);</li></ul><ul><li>box.onclick = fn.call(obj, 200);<br>​```</li></ul><p>效果如下</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="deletion">- box.onclick = fn.bind(obj, 200);</span></span><br><span class="line"><span class="addition">+ box.onclick = fn.call(obj, 200);</span></span><br></pre></td></tr></table></figure><h3 id="3-3-折叠效果"><a href="#3-3-折叠效果" class="headerlink" title="3.3 折叠效果"></a>3.3 折叠效果</h3><p>添加冗长的错误日志或冗长程序输出的问题可以解决的错误有帮助的，但如果它占用页的垂直空间，可以考虑使用<code>&lt;details&gt;</code>和<code>&lt;summary&gt;</code>标签。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Having some problems firing up the laser.</span><br><span class="line"></span><br><span class="line">&lt;details&gt;</span><br><span class="line">&lt;summary&gt;Click here to see terminal history + debug info&lt;&#x2F;summary&gt;</span><br><span class="line">&lt;pre&gt;</span><br><span class="line">488 cd &#x2F;opt&#x2F;LLL&#x2F;controller&#x2F;laser&#x2F;</span><br><span class="line">489 vi LLLSDLaserControl.c</span><br><span class="line">490 make</span><br><span class="line">491 make install</span><br><span class="line">492 &#x2F;images&#x2F;2020&#x2F;04&#x2F;29&#x2F;sanity_check</span><br><span class="line">493 &#x2F;images&#x2F;2020&#x2F;04&#x2F;29&#x2F;configure -o test.cfg</span><br><span class="line">494 vi test.cfg</span><br><span class="line">495 vi ~&#x2F;last_will_and_testament.txt</span><br><span class="line">496 cat &#x2F;proc&#x2F;meminfo</span><br><span class="line">497 ps -a -x -u</span><br><span class="line">498 kill -9 2207</span><br><span class="line">499 kill 2208</span><br><span class="line">500 ps -a -x -u</span><br><span class="line">501 touch &#x2F;opt&#x2F;LLL&#x2F;run&#x2F;ok</span><br><span class="line">502 LLLSDLaserControl -ok1</span><br><span class="line">&lt;&#x2F;pre&gt;</span><br><span class="line">&lt;details&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><details><summary>Click here to see terminal history + debug info</summary><pre>488 cd /opt/LLL/controller/laser/489 vi LLLSDLaserControl.c490 make491 make install492 /images/2020/04/29/sanity_check493 /images/2020/04/29/configure -o test.cfg494 vi test.cfg495 vi ~/last_will_and_testament.txt496 cat /proc/meminfo497 ps -a -x -u498 kill -9 2207499 kill 2208500 ps -a -x -u501 touch /opt/LLL/run/ok502 LLLSDLaserControl -ok1</pre></details><h3 id="3-4-使文字和图像居中"><a href="#3-4-使文字和图像居中" class="headerlink" title="3.4  使文字和图像居中"></a>3.4  使文字和图像居中</h3><p>在 MarkDown 中直接是使用居中DIV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;rain7.top&#x2F;luckrain7.png&quot; width&#x3D;&quot;350&quot;&gt;</span><br><span class="line">&lt;p&gt;This is RainCode&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><div align="center"><img src="https://rain7.top/luckrain7.png" width="350"><p>This is RainCode</p></div><h3 id="3-5-较小的文字"><a href="#3-5-较小的文字" class="headerlink" title="3.5 较小的文字"></a>3.5 较小的文字</h3><p> 在<code>&lt;sup&gt;</code>或<code>&lt;sub&gt;</code>标记中换行以使其变小。非常适合在图像下添加“图1：描述”之类的内容，或者使表中的文本变小以使其不会水平滚动。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">&lt;img src&#x3D;&quot;https:&#x2F;&#x2F;rain7.top&#x2F;luckrain7.png&quot; width&#x3D;&quot;350&quot;&gt;&lt;br&gt;</span><br><span class="line">&lt;sup&gt;&lt;strong&gt;Fig 1:&lt;&#x2F;strong&gt; luckrain7&#39;s logo&lt;&#x2F;sup&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>效果如下：</p><div align="center"><img src="https://rain7.top/luckrain7.png" width="350"><br><sup><strong>Fig 1:</strong> luckrain7's logo</sup></div><h2 id="4-徽标制作"><a href="#4-徽标制作" class="headerlink" title="4.徽标制作"></a>4.徽标制作</h2><p>下面教程是简单的常规用法</p><p>1.首先登陆网站： <a href="https://shields.io/" target="_blank" rel="noopener">https://shields.io/</a></p><p>2.向下滑动，找到 <code>Static</code> 功能标题，如图进行制作</p><p><img src="/images/2020/04/29/shieldsio.png" alt=""></p><p>3.页面会跳转到制作好的徽标页面，右击点击徽标(SVG格式)保存到本地</p><p>4.使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">将图片上传到自己的图床中或仅本地使用</span><br><span class="line">使用图片嵌套格式使用</span><br><span class="line">[![](&#x2F;images&#x2F;2020&#x2F;04&#x2F;29&#x2F;RainCode.svg)](https:&#x2F;&#x2F;mp.weixin.qq.com&#x2F;s&#x2F;-kBwis0MhRNgVEtDF7wPYA)</span><br></pre></td></tr></table></figure><p><a href="https://mp.weixin.qq.com/s/-kBwis0MhRNgVEtDF7wPYA" target="_blank" rel="noopener"><img src="/images/2020/04/29/RainCode.svg" alt=""></a></p><h2 id="5-修改仓库语言"><a href="#5-修改仓库语言" class="headerlink" title="5.  修改仓库语言"></a>5.  修改仓库语言</h2><p>项目仓库是根据根目录下的文件类型进行判断，哪种类型多，仓库就在仓库列表界面显示哪种语言类型</p><p>修改步骤：</p><p>1.在项目中添加文件 <code>.gitattributes</code></p><p>2.输入以下内容（重置识别类型）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*.[扩展名] linguist-language&#x3D;[将此文件识别为哪种语言]</span><br><span class="line"></span><br><span class="line"># 我这以vue为例</span><br><span class="line">*.js linguist-language&#x3D;vue</span><br><span class="line">*.css linguist-language&#x3D;vue</span><br><span class="line">*.html linguist-language&#x3D;vue</span><br><span class="line">*.sh linguist-language&#x3D;vue</span><br></pre></td></tr></table></figure><p>这样项目仓库语言会被修改为 vue</p><h4 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h4><p><a href="https://github.blog/2020-04-09-github-protips-tips-tricks-hacks-and-secrets-from-lee-reilly/" target="_blank" rel="noopener">https://github.blog/2020-04-09-github-protips-tips-tricks-hacks-and-secrets-from-lee-reilly/</a></p><h3 id="推荐阅读："><a href="#推荐阅读：" class="headerlink" title="推荐阅读："></a>推荐阅读：</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/fJO-7OnSE82t6Gqqt8n0Fg" target="_blank" rel="noopener">一道关于JavaScript 代码执行顺序的面试题解析</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/39J2KO8h_cBKg3MWB63L7w" target="_blank" rel="noopener">如何在 Array.forEach 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/OtFsaLb2a26D0Uz4aFaoAw" target="_blank" rel="noopener">如何在 Array.filter 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9wl8-SYspr3s358Tf0CmSg" target="_blank" rel="noopener">如何在 Array.reduce 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PdghejWyUjfWLBdOagPkkA" target="_blank" rel="noopener">如何在 Array.map 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/QLabNBOChsKmrpvEXJrpNg" target="_blank" rel="noopener">一道“简单”的This题解析</a></p></li></ul><p>如果对你有所帮助，可以点赞、收藏。</p>]]></content>
      
      
      <categories>
          
          <category> GitHub </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GitHub </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Array.some 中正确使用 async</title>
      <link href="/2020/04/24/async-in-Array.some/"/>
      <url>/2020/04/24/async-in-Array.some/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2020/04/24/%E5%B0%81%E9%9D%A2.png" alt="封面"></p><blockquote><p> 使用 <code>Promise</code> 检查集合 </p><p>本文译自：<a href="https://advancedweb.hu/how-to-use-async-functions-with-array-some-and-every-in-javascript/" target="_blank" rel="noopener">How to use async functions with Array.some and every in Javascript - </a></p></blockquote><p>在<a href="https://advancedweb.hu/asynchronous-array-functions-in-javascript/" target="_blank" rel="noopener">第一篇文章中</a>， 我们介绍了async / await 如何帮助执行异步命令 ，但是在异步处理集合时却无济于事。在这篇文章中，当结果为布尔值时，我们将研究 <code>some</code> 和 <code>every</code> 函数用于更有效的 <code>reduce</code></p><h2 id="1-some-和-every-函数"><a href="#1-some-和-every-函数" class="headerlink" title="1.  some 和 every 函数"></a>1.  some 和 every 函数</h2><p>这些函数与<code>filter</code>一样，获得递归函数，但是它们根据断言函数是否返回特定值而返回单个 <code>true / false</code>。对于<code>some</code>，如果任何断言函数返回 <code>true</code>，则结果为true。对于该<code>every</code>函数，如果返回任何<code>false</code>，则结果将为<code>false</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> someRes = arr.some(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(someRes);</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> everyRes = arr.every(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i &lt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(everyRes);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><h2 id="2-异步-some-every"><a href="#2-异步-some-every" class="headerlink" title="2.  异步 some/every"></a>2.  异步 some/every</h2><h3 id="2-1-使用异步-filter"><a href="#2-1-使用异步-filter" class="headerlink" title="2.1  使用异步  filter"></a>2.1  使用异步  filter</h3><p>仅考虑结果，可以使用 <code>async</code> 来模拟这些函数<code>filter</code>，在上一篇文章中已经介绍了如何将其转换为<code>async</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync</span></span><br><span class="line"><span class="keyword">const</span> some = <span class="function">(<span class="params">arr, predicate</span>) =&gt;</span> arr.filter(predicate).length &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> every = <span class="function">(<span class="params">arr, predicate</span>) =&gt;</span> arr.filter(predicate).length === arr.length;</span><br><span class="line"></span><br><span class="line"><span class="comment">// async</span></span><br><span class="line"><span class="keyword">const</span> asyncSome =</span><br><span class="line"><span class="keyword">async</span> (arr, predicate) =&gt; (<span class="keyword">await</span> asyncFilter(arr, predicate)).length &gt; <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> asyncEvery =</span><br><span class="line"><span class="keyword">async</span> (arr, predicate) =&gt; (<span class="keyword">await</span> asyncFilter(arr, predicate)).length === arr.length;</span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/24/Filter-based-async-some.png" alt="Filter-based-async-some"></p><h4 id="短路（Short-circuiting）"><a href="#短路（Short-circuiting）" class="headerlink" title="短路（Short-circuiting）"></a>短路（Short-circuiting）</h4><p>但是，内置的<code>some</code>/ <code>every</code>函数和<code>filter</code>的实现之间存在重要的区别。当有一个元素为时返回true时，<code>some</code>将短路并且不处理其余元素：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = arr.some(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Checking <span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">return</span> i % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Checking 1</span></span><br><span class="line"><span class="comment">// Checking 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/24/Synchronous-some.png" alt="Synchronous-some"></p><p>同样，<code>every</code>在第一个错误结果之后停止：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = arr.every(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Checking <span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">return</span> i &lt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Checking 1</span></span><br><span class="line"><span class="comment">// Checking 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>让我们看看如何编写一个异步版本，该版本以类似的方式工作并且工作量最少！</p><h3 id="2-2-异步-some"><a href="#2-2-异步-some" class="headerlink" title="2.2  异步 some"></a>2.2  异步 some</h3><p>最好的解决方案是使用异步<strong>进行迭代</strong>，并在找到结果为 <code>true</code> 后立即返回：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncSome = <span class="keyword">async</span> (arr, predicate) =&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">await</span> predicate(e)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> asyncSome(arr, <span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Checking <span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> i % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Checking 1</span></span><br><span class="line"><span class="comment">// Checking 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/24/For-based-async-some.png" alt="For-based-async-some"></p><p>对于第一个元素<code>predicate(e)</code>返回结果为 <code>true</code>，它结束了for循环。</p><h3 id="2-3-异步-every"><a href="#2-3-异步-every" class="headerlink" title="2.3  异步 every"></a>2.3  异步 every</h3><p>类似的结构适用于<code>every</code>，这只是对条件求反的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncEvery = <span class="keyword">async</span> (arr, predicate) =&gt; &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> e <span class="keyword">of</span> arr) &#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">await</span> predicate(e)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> asyncEvery(arr, <span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Checking <span class="subst">$&#123;i&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> i &lt; <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Checking 1</span></span><br><span class="line"><span class="comment">// Checking 2</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>只要<code>predicate(e)</code>返回false，函数便会终止而不检查其他元素。</p><h3 id="2-4-并行处理"><a href="#2-4-并行处理" class="headerlink" title="2.4  并行处理"></a>2.4  并行处理</h3><p>短路（ short-circuiting ）实现顺序地处理元素，这在资源使用方面很有效，但可能导致执行时间更长。</p><p>例如，如果通过递归发送网络请求，则一次发送一个请求可能会花费一些时间。另一方面，虽然这可能导致发送更多的请求，但同时发送所有请求会更快。</p><h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3.  结论"></a>3.  结论</h2><p><code>some</code>和<code>every</code>功能很接近异步<code>filter</code>，但要严格遵循同步规范，异步<code>for</code>循环是一个更好的选择。</p><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><ul><li><p><a href="https://mp.weixin.qq.com/s/39J2KO8h_cBKg3MWB63L7w" target="_blank" rel="noopener">如何在 Array.forEach 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/OtFsaLb2a26D0Uz4aFaoAw" target="_blank" rel="noopener">如何在 Array.filter 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9wl8-SYspr3s358Tf0CmSg" target="_blank" rel="noopener">如何在 Array.reduce 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/PdghejWyUjfWLBdOagPkkA" target="_blank" rel="noopener">如何在 Array.map 中正确使用 async</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async </tag>
            
            <tag> Array </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何正确的在 Array.map 使用 async</title>
      <link href="/2020/04/22/async-in-Array.map/"/>
      <url>/2020/04/22/async-in-Array.map/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 在 <code>map</code> 中返回Promises，然后等待结果 </p><p>  本文译自<a href="https://advancedweb.hu/how-to-use-async-functions-with-array-map-in-javascript/" target="_blank" rel="noopener">How to use async functions with Array.map in Javascript - <strong>Tamás Sallai</strong> </a>。 </p></blockquote><p>在前面的文章中，我们介绍了 async / await如何帮助执行异步命令 ，但在异步处理集合时却无济于事。在本文中，我们将研究该<code>map</code>函数，该函数是最常用的函数，它将数据从一种形式转换为另一种形式（这里可以理解为 <code>map</code>具有返回值）。 </p><h2 id="1-Array-map"><a href="#1-Array-map" class="headerlink" title="1.  Array.map"></a>1.  Array.map</h2><p>该<code>map</code>是最简单和最常见的采集功能。它通过迭代函数运行每个元素，并返回包含结果的数组。</p><p>向每个元素添加一的同步版本：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> syncRes = arr.map(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(syncRes);</span><br><span class="line"><span class="comment">// 2,3,4</span></span><br></pre></td></tr></table></figure><p>异步版本需要做两件事。首先，它需要将每个项目映射到具有新值的 <code>Promise</code>，这是<code>async</code>在函数执行之前添加的内容。</p><p>其次，它需要等待所有<code>Promises</code>，然后将结果收集到Array中。幸运的是，<code>Promise.all</code>内置调用正是我们执行步骤2所需的。</p><p>这使得一个异步的一般模式<code>map</code>是<code>Promise.all(arr.map(async (...) =&gt; ...))</code>。</p><p>异步实现与同步实现相同：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncRes = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(arr.map(<span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(asyncRes);</span><br><span class="line"><span class="comment">// 2,3,4</span></span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/22/Async-map.png" alt="Async map"></p><h2 id="2-并发"><a href="#2-并发" class="headerlink" title="2.  并发"></a>2.  并发</h2><p>上面的实现为数组的每个元素并行运行迭代函数。通常这很好，但是在某些情况下，它可能会消耗过多的资源。当异步函数访问 <code>API</code> 或消耗过多的RAM以至于无法一次运行太多RAM时，可能会发生这种情况。</p><p>尽管异步<code>map</code>易于编写，但要增加并发控件。在接下来的几个示例中，我们将研究不同的解决方案。</p><h3 id="2-1-批量处理"><a href="#2-1-批量处理" class="headerlink" title="2.1  批量处理"></a>2.1  批量处理</h3><p>最简单的方法是对元素进行分组并逐个处理。这使您可以控制一次可以运行的最大并行任务数。但是由于一组必须在下一组开始之前完成，因此每组中最慢的元素成为限制因素。</p><p><img src="/images/2020/04/22/Mapping-in-groups.png" alt="Mapping in groups"></p><p>为了进行分组，下面的示例使用<code>Underscore.js</code>的<code>groupBy</code>实现。许多库提供了一种实现，并且它们大多数都是可互换的。<code>Lodash</code>是个例外，因为其 <code>groupBy</code> 不传递 <code>item</code>的索引。</p><p>如果您不熟悉<code>groupBy</code>，它将通过迭代函数运行每个元素，并返回一个对象，其键为结果，值为产生该值的元素的列表。</p><p>为了使群体最多<code>n</code>的元素，一个迭代器 <code>Math.floor(i / n)</code>，其中 <code>i</code> 是元素的索引。例如，一组大小为3的元素将映射以下元素：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">0 &#x3D;&gt; 0</span><br><span class="line">1 &#x3D;&gt; 0</span><br><span class="line">2 &#x3D;&gt; 0</span><br><span class="line">3 &#x3D;&gt; 1</span><br><span class="line">4 &#x3D;&gt; 1</span><br><span class="line">5 &#x3D;&gt; 1</span><br><span class="line">6 &#x3D;&gt; 2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Javascript实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">30</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(</span><br><span class="line">_.groupBy(arr, (_v, i) =&gt; <span class="built_in">Math</span>.floor(i / <span class="number">3</span>))</span><br><span class="line">);</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">// 0: [30, 10, 20],</span></span><br><span class="line"><span class="comment">// 1: [20, 15, 20],</span></span><br><span class="line"><span class="comment">// 2: [10]</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure><p>最后一组可能比其他组小，但是保证所有组都不会超过最大组大小。</p><p>要映射一组，通常的<code>Promise.all(group.map(...))</code>构造是很好。</p><p>要按顺序映射组，我们需要一个reduce，它将先前的结果（<code>memo</code>）与当前组的结果连接起来：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.values(groups)</span><br><span class="line">.reduce(<span class="keyword">async</span> (memo, group) =&gt; [</span><br><span class="line">...(<span class="keyword">await</span> memo),</span><br><span class="line">...(<span class="keyword">await</span> <span class="built_in">Promise</span>.all(group.map(iteratee)))</span><br><span class="line">], []);</span><br></pre></td></tr></table></figure><p>此实现基于以下事实：<code>await memo</code>等待上一个结果的完成才进行下一个任务。</p><p>实现批处理的完整实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">30</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapInGroups = <span class="function">(<span class="params">arr, iteratee, groupSize</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> groups = _.groupBy(arr, (_v, i) =&gt; <span class="built_in">Math</span>.floor(i / groupSize));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="built_in">Object</span>.values(groups)</span><br><span class="line">.reduce(<span class="keyword">async</span> (memo, group) =&gt; [</span><br><span class="line">...(<span class="keyword">await</span> memo),</span><br><span class="line">...(<span class="keyword">await</span> <span class="built_in">Promise</span>.all(group.map(iteratee)))</span><br><span class="line">], []);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> mapInGroups(arr, <span class="keyword">async</span> (v) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`S <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">await</span> sleep(v);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`F <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">&#125;, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// -- first batch --</span></span><br><span class="line"><span class="comment">// S 30</span></span><br><span class="line"><span class="comment">// S 10</span></span><br><span class="line"><span class="comment">// S 20</span></span><br><span class="line"><span class="comment">// F 10</span></span><br><span class="line"><span class="comment">// F 20</span></span><br><span class="line"><span class="comment">// F 30</span></span><br><span class="line"><span class="comment">// -- second batch --</span></span><br><span class="line"><span class="comment">// S 20</span></span><br><span class="line"><span class="comment">// S 15</span></span><br><span class="line"><span class="comment">// S 20</span></span><br><span class="line"><span class="comment">// F 15</span></span><br><span class="line"><span class="comment">// F 20</span></span><br><span class="line"><span class="comment">// F 20</span></span><br><span class="line"><span class="comment">// -- third batch --</span></span><br><span class="line"><span class="comment">// S 10</span></span><br><span class="line"><span class="comment">// F 10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 31,11,21,21,16,21,11</span></span><br></pre></td></tr></table></figure><h3 id="2-2-并行处理"><a href="#2-2-并行处理" class="headerlink" title="2.2  并行处理"></a>2.2  并行处理</h3><p>并发控制的另一种类型是并行执行大多数<code>n</code>任务，并在完成一项任务时启动一个新任务。</p><p><img src="/images/2020/04/22/Controlled-concurrency.png" alt=" Controlled concurrency "></p><p>我无法为此提供一个简单的实现，但是幸运的是，Bluebird提供了一个开箱即用的库。这很简单，只需导入库并使用<code>Promise.map</code>支持该<code>concurrency</code>选项的功能即可。</p><p>在下面的示例中，并发限制为<code>2</code>，这意味着立即启动2个任务，然后每完成一个任务，就开始一个新任务，直到没有剩余：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">30</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Bluebird promise</span></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> <span class="built_in">Promise</span>.map(arr, <span class="keyword">async</span> (v) =&gt; &#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`S <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line"><span class="keyword">await</span> sleep(v);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`F <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">return</span> v + <span class="number">1</span>;</span><br><span class="line">&#125;, &#123;<span class="attr">concurrency</span>: <span class="number">2</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// S 30</span></span><br><span class="line"><span class="comment">// S 10</span></span><br><span class="line"><span class="comment">// F 10</span></span><br><span class="line"><span class="comment">// S 10</span></span><br><span class="line"><span class="comment">// F 30</span></span><br><span class="line"><span class="comment">// S 20</span></span><br><span class="line"><span class="comment">// F 10</span></span><br><span class="line"><span class="comment">// S 15</span></span><br><span class="line"><span class="comment">// F 20</span></span><br><span class="line"><span class="comment">// S 20</span></span><br><span class="line"><span class="comment">// F 15</span></span><br><span class="line"><span class="comment">// S 20</span></span><br><span class="line"><span class="comment">// F 20</span></span><br><span class="line"><span class="comment">// F 20</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 31,11,21,21,16,21,11</span></span><br></pre></td></tr></table></figure><h3 id="2-3-顺序处理"><a href="#2-3-顺序处理" class="headerlink" title="2.3  顺序处理"></a>2.3  顺序处理</h3><p>有时，并发太多，因此应该一个接一个地处理元素。</p><p><img src="/images/2020/04/22/Mapping-sequentially.png" alt="Mapping-sequentially"></p><p>一个简单的实现是使用并发性为 1 的 <code>Bluebird</code> 的 <code>Promise</code>。但是在这种情况下，它不保证包括一个库，因为<code>reduce</code>这样做很简单：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> res = <span class="keyword">await</span> arr.reduce(<span class="keyword">async</span> (memo, v) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> memo;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`S <span class="subst">$&#123;v&#125;</span>`</span>)</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">10</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`F <span class="subst">$&#123;v&#125;</span>`</span>);</span><br><span class="line"><span class="keyword">return</span> [...results, v + <span class="number">1</span>];</span><br><span class="line">&#125;, []);</span><br><span class="line"></span><br><span class="line"><span class="comment">// S 1</span></span><br><span class="line"><span class="comment">// F 1</span></span><br><span class="line"><span class="comment">// S 2</span></span><br><span class="line"><span class="comment">// F 2</span></span><br><span class="line"><span class="comment">// S 3</span></span><br><span class="line"><span class="comment">// F 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(res);</span><br><span class="line"><span class="comment">// 2,3,4</span></span><br></pre></td></tr></table></figure><p>确保在执行任何其他操作之前 <code>await memo</code>，因为如果没有 <code>await</code>，它仍然会并发运行！</p><h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3.  结论"></a>3.  结论</h2><p>该<code>map</code>功能很容易转换为异步，因为<code>Promise.all</code>内置功能繁重。但是控制并发需要一些计划。</p><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/mFmqyicyfaAOdxmhlPmSRQ" target="_blank" rel="noopener">如何在 Vue 中优雅的使用防抖节流</a> </p></li><li><p><a href="https://mp.weixin.qq.com/s/39J2KO8h_cBKg3MWB63L7w" target="_blank" rel="noopener">如何在 Array.forEach 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/OtFsaLb2a26D0Uz4aFaoAw" target="_blank" rel="noopener">如何在 Array.filter 中正确使用 async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9wl8-SYspr3s358Tf0CmSg" target="_blank" rel="noopener">如何在 Array.reduce 中正确使用 async</a></p></li></ul><p>如果对你有所帮助，可以点赞、收藏。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async </tag>
            
            <tag> Array </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道关于JavaScript 代码执行顺序的面试题解析</title>
      <link href="/2020/04/20/javascript-execution-order/"/>
      <url>/2020/04/20/javascript-execution-order/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2020/04/20/javascript.png" alt="javascript"></p><h2 id="0-引言："><a href="#0-引言：" class="headerlink" title="0.  引言："></a>0.  引言：</h2><p>最近写了一些异步递归的代码，着实有点头疼，索性重新研究一下JavaScript 代码执行顺序，并附上一道面试题的解析。</p><h2 id="1-JavaScript-代码执行顺序"><a href="#1-JavaScript-代码执行顺序" class="headerlink" title="1.  JavaScript 代码执行顺序"></a>1.  JavaScript 代码执行顺序</h2><blockquote><p>首先我们了解几个概念</p></blockquote><h3 id="1-1-微任务-宏任务"><a href="#1-1-微任务-宏任务" class="headerlink" title="1.1  微任务/宏任务"></a>1.1  微任务/宏任务</h3><p>异步队列中包括：微任务（micro-task） 和 宏任务（macro-task） </p><p>微任务包括： <code>process.nextTick</code> ，<code>Promise</code> （ <code>process.nextTick</code> 为 Node 独有）</p><p>宏任务包括： <code>script</code> ， <code>setTimeout</code> ，<code>setInterval</code> ，<code>setImmediate</code> ，<code>I/O</code> ，<code>UI rendering</code></p><p>Tips：</p><ul><li>微任务优先级高于宏任务的前提是：同步代码已经执行完成。因为 <code>script</code>  属于宏任务，程序开始后会首先执行同步脚本，也就是<code>script</code> 。</li><li><code>Promise</code> 里边的代码属于同步代码，<code>.then()</code> 中执行的代码才属于异步代码。</li></ul><h3 id="1-2-Event-Loop（事件轮询）"><a href="#1-2-Event-Loop（事件轮询）" class="headerlink" title="1.2  Event Loop（事件轮询）"></a>1.2  Event Loop（事件轮询）</h3><p>Event Loop 是一个程序结构，用于等待和发送消息和事件。</p><p>Event Loop 执行顺序如下所示：</p><ul><li>首先执行同步代码（宏任务）</li><li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li><li>执行所有微任务</li><li>当执行完所有微任务后，如有必要会渲染页面</li><li>然后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 <code>setTimeout</code> 中的回调函数</li></ul><p>Tips：简化讲：先执行一个宏任务（script同步代码），然后执行并清空微任务，再执行一个宏任务，然后执行并清空微任务，再执行一个宏任务，再然后执行并清空微任务……如此循环往复（一个宏任务 -&gt; 清空微任务 -&gt; 一个宏任务 -&gt; 清空微任务）</p><p><img src="/images/2020/04/20/javascript%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.png" alt="javascript代码执行顺序"></p><h2 id="2-面试题详解"><a href="#2-面试题详解" class="headerlink" title="2.  面试题详解"></a>2.  面试题详解</h2><h3 id="2-1-题目"><a href="#2-1-题目" class="headerlink" title="2.1  题目"></a>2.1  题目</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">" set1"</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"then4"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then2 "</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"pr1"</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then1"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"set2"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then3"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-2-执行过程解析"><a href="#2-2-执行过程解析" class="headerlink" title="2.2  执行过程解析"></a>2.2  执行过程解析</h3><p>执行所有同步代码（第一次宏任务）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// setTimeout 内 function 放入宏任务</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">" set1"</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"then4"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then2 "</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"pr1"</span>); <span class="comment">// Promise里边的代码直接执行  打印 pr1</span></span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then1"</span>); <span class="comment">// Promise.then 放入微任务</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"set2"</span>); <span class="comment">// setTimeout内function 放入宏任务</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>); <span class="comment">// 打印 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then3"</span>); <span class="comment">//Promise.then 放入微任务</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时控制台打印 ： pr1  &gt;  2</span></span><br><span class="line"><span class="comment">// 异步任务队列：[微任务数:2][宏任务数：2]</span></span><br><span class="line"><span class="comment">// 执行并清空微任务</span></span><br></pre></td></tr></table></figure><p>执行并清空微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then1"</span>);  <span class="comment">// 输出 then1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"then3"</span>); <span class="comment">// 输出 then3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时控制台打印 ： then1  &gt;  then3</span></span><br><span class="line"><span class="comment">// 异步任务：[微任务数:0][宏任务数：2]</span></span><br><span class="line"><span class="comment">// 执行一个宏任务</span></span><br></pre></td></tr></table></figure><p>执行一个宏任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">" set1"</span>);   <span class="comment">//打印 set1</span></span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolve();</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     <span class="comment">// Promise.then 放入微任务</span></span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"then4"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then2 "</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时控制台打印 ： set1</span></span><br><span class="line"><span class="comment">// 异步任务：[微任务数:1][宏任务数：1]</span></span><br><span class="line"><span class="comment">// 执行并清空微任务</span></span><br></pre></td></tr></table></figure><p>执行并清空微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;     </span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">      resolve();      </span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"then4"</span>);   <span class="comment">// Promise.then 放入微任务</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"then2 "</span>);    <span class="comment">// 打印 then2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时控制台打印 ： then2</span></span><br><span class="line"><span class="comment">// 异步任务：[微任务数:1][宏任务数：1]</span></span><br><span class="line"><span class="comment">// 此时微任务列表增加并未清空，继续执行微任务</span></span><br></pre></td></tr></table></figure><p>此时微任务列表增加并未清空，继续执行微任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">"then4"</span>);   <span class="comment">// 打印 then4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此时控制台打印 ： then4</span></span><br><span class="line"><span class="comment">// 异步任务：[微任务数:0][宏任务数：1]</span></span><br><span class="line"><span class="comment">// 执行宏任务</span></span><br></pre></td></tr></table></figure><p>执行宏任务</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"set2"</span>); <span class="comment">// 打印 set2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时控制台打印 ： set2</span></span><br><span class="line"><span class="comment">// 异步任务：[微任务数:0][宏任务数：0]</span></span><br><span class="line"><span class="comment">// 程序结束</span></span><br></pre></td></tr></table></figure><p>完整输入顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pr1</span><br><span class="line"><span class="number">2</span></span><br><span class="line">then1</span><br><span class="line">then3</span><br><span class="line">set1</span><br><span class="line">then2 </span><br><span class="line">then4</span><br><span class="line">set2</span><br></pre></td></tr></table></figure><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><p><a href="https://mp.weixin.qq.com/s/QLabNBOChsKmrpvEXJrpNg" target="_blank" rel="noopener">一道“简单”的 This 题解析</a> </p></li><li><p><a href="https://rain7.top/article/如何在Vue中优雅的使用防抖节流.html" target="_blank" rel="noopener">如何在Vue中优雅的使用防抖、节流</a> </p></li><li><p><a href="https://rain7.top/article/如何在Javascript中对Array.forEach使用异步函数.html" target="_blank" rel="noopener">如何在 Array.forEach 中正确使用 Async</a></p></li><li><p><a href="https://rain7.top/article/如何在Array.filter中正确使用Async.html" target="_blank" rel="noopener">如何在 Array.filter 中正确使用 Async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/9wl8-SYspr3s358Tf0CmSg" target="_blank" rel="noopener">如何在 Array.reduce 中正确使用 async</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常用命令及应用这一篇就够了（新手向）</title>
      <link href="/2020/04/17/git-use/"/>
      <url>/2020/04/17/git-use/</url>
      
        <content type="html"><![CDATA[<h2 id="1-git-常用命令"><a href="#1-git-常用命令" class="headerlink" title="1.  git 常用命令"></a>1.  git 常用命令</h2><h3 id="1-1-常用命令"><a href="#1-1-常用命令" class="headerlink" title="1.1   常用命令"></a>1.1   常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化git</span></span><br><span class="line">git init </span><br><span class="line"></span><br><span class="line"><span class="comment"># 克隆项目</span></span><br><span class="line">git <span class="built_in">clone</span> [url] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示文件状态</span></span><br><span class="line">git status -s </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加文件到暂存区</span></span><br><span class="line">git add . <span class="comment">#添加所有文件到暂存区</span></span><br><span class="line">git add [文件名] <span class="comment">#添加指定文件到暂存区</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提交暂存区到仓库区</span></span><br><span class="line">git commit -m [提交信息] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取远程仓库的变化，更新本地分支</span></span><br><span class="line">git pull </span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送到远程仓库</span></span><br><span class="line">git push </span><br><span class="line">git push [远程主机名] [本地分支名]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新所有的远程仓库信息</span></span><br><span class="line">git fetch --all </span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并指定分支到当前分支</span></span><br><span class="line">git merge [分支名] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 分支相关</span></span><br><span class="line">git branch <span class="comment"># 列出所有本地分支</span></span><br><span class="line">git checkout [分支名] <span class="comment"># 切换到指定分支</span></span><br><span class="line">git checkout -b [本地分支名] origin/[远程分支名] <span class="comment"># 拉取远程分支</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看项目中git配置</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置全局信息</span></span><br><span class="line">git config --global user.name <span class="string">"[name]"</span></span><br><span class="line">git config --global user.email <span class="string">"[email address]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目中配置</span></span><br><span class="line">git config user.name <span class="string">"[name]"</span></span><br><span class="line">git config user.email <span class="string">"[email address]"</span></span><br></pre></td></tr></table></figure><h3 id="1-2-git-remote"><a href="#1-2-git-remote" class="headerlink" title="1.2  git remote"></a>1.2  git remote</h3><blockquote><p>管理远程仓库 </p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看远程仓库</span></span><br><span class="line">git remote </span><br><span class="line"></span><br><span class="line"><span class="comment">#查看关联的远程仓库的详细信息</span></span><br><span class="line">git remote -v </span><br><span class="line"></span><br><span class="line"><span class="comment">#添加远程仓库的关联</span></span><br><span class="line">git remote add origin [远程仓库地址] </span><br><span class="line"></span><br><span class="line"><span class="comment">#删除远程仓库的关联</span></span><br><span class="line">git remote remove [远程仓库名称] </span><br><span class="line"></span><br><span class="line"><span class="comment">#更新远程仓库的分支</span></span><br><span class="line">git remote update origin --prune</span><br></pre></td></tr></table></figure><h3 id="1-3-git-rebase"><a href="#1-3-git-rebase" class="headerlink" title="1.3  git rebase"></a>1.3  git rebase</h3><blockquote><p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p><p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p><p>个人感觉非特定情况，还是不建议使用</p></blockquote><h2 id="2-Git的常见应用"><a href="#2-Git的常见应用" class="headerlink" title="2.  Git的常见应用"></a>2.  Git的常见应用</h2><h3 id="2-1-本地项目上传至多个远程库"><a href="#2-1-本地项目上传至多个远程库" class="headerlink" title="2.1  本地项目上传至多个远程库"></a>2.1  本地项目上传至多个远程库</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加关联远程库(这里以github和码云为例，大家替换掉仓库地址即可)</span></span><br><span class="line">git remote add gitee [url]</span><br><span class="line">git remote add gitee git@gitee.com:LuckRain/Knowledge-Sharing.git</span><br><span class="line">git remote add github git@github.com:LuckRain7/Knowledge-Sharing.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 推送时分别将master分支推送到关联远程库</span></span><br><span class="line">git push gitee master</span><br><span class="line">git push github master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除关联远程库</span></span><br><span class="line">git remote rm [origin]</span><br></pre></td></tr></table></figure><h3 id="2-2-Git-远程分支强制覆盖本地分支"><a href="#2-2-Git-远程分支强制覆盖本地分支" class="headerlink" title="2.2  Git 远程分支强制覆盖本地分支"></a>2.2  Git 远程分支强制覆盖本地分支</h3><blockquote><p>需在需要覆盖的分支上进行一下操作</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 更新所有的远程仓库信息</span></span><br><span class="line">git fetch --all  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制重置为 origin/master（可以换成你需要的远程分支） 远程分支</span></span><br><span class="line">git reset --hard [origin/master] </span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉取最新代码</span></span><br><span class="line">git pull</span><br></pre></td></tr></table></figure><h3 id="2-3-Git-配置忽略规则-gitignore）不生效解决方案"><a href="#2-3-Git-配置忽略规则-gitignore）不生效解决方案" class="headerlink" title="2.3  Git 配置忽略规则(.gitignore）不生效解决方案"></a>2.3  Git 配置忽略规则(.gitignore）不生效解决方案</h3><blockquote><p> 清除缓存 重新提交</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 清除缓存</span></span><br><span class="line">git rm -r --cached .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有文件添加到缓存区</span></span><br><span class="line">git add . </span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加提交信息</span></span><br><span class="line">git commit -m <span class="string">'update .gitignore'</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制覆盖 以远程分支 rain 为例</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="2-4-Git-强制提交本地分支覆盖远程分支"><a href="#2-4-Git-强制提交本地分支覆盖远程分支" class="headerlink" title="2.4  Git 强制提交本地分支覆盖远程分支"></a>2.4  Git 强制提交本地分支覆盖远程分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将所有文件添加到缓存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加提交信息</span></span><br><span class="line">git commit -m <span class="string">'更新信息'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制覆盖 以远程分支 rain 为例</span></span><br><span class="line">git push origin rain --force</span><br></pre></td></tr></table></figure><h3 id="2-5-分支合并"><a href="#2-5-分支合并" class="headerlink" title="2.5 分支合并"></a>2.5 分支合并</h3><h4 id="2-5-1-情景："><a href="#2-5-1-情景：" class="headerlink" title="2.5.1  情景："></a>2.5.1  情景：</h4><p>我现在的分支是 rain</p><p>我要把别人的分支 snow 合并到我的分支上来</p><h4 id="2-5-2-操作："><a href="#2-5-2-操作：" class="headerlink" title="2.5.2  操作："></a>2.5.2  操作：</h4><ol><li>首先要进行切换分支（切换分支前要保证自己分支的内容都已经提交了）</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 情况一:分支是本地分支(直接切换)</span></span><br><span class="line">git branch snow  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 情况二:分支是远程分支(新建本地分支并与远程分支关联)</span></span><br><span class="line">git checkout -b snow origin/snow</span><br></pre></td></tr></table></figure><ol start="2"><li>在 snow 分支上拉取最新代码</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><ol start="3"><li>切换回我自己的分支rain</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch rain</span><br></pre></td></tr></table></figure><ol start="4"><li>执行合并</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge rain</span><br></pre></td></tr></table></figure><ol start="5"><li>处理代码冲突</li></ol><p>我这里比较喜欢使用 VS Code 的可视化界面解决代码冲突</p><h3 id="2-6-版本回溯"><a href="#2-6-版本回溯" class="headerlink" title="2.6  版本回溯"></a>2.6  版本回溯</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#版本回退到上一个版本</span></span><br><span class="line">git reset --hard HEAD^ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 回溯到指定版本</span></span><br><span class="line">git <span class="built_in">log</span> <span class="comment">#查看git历史版本信息，并找到指定版本的commit id</span></span><br><span class="line">git reset --hard [commitId]  <span class="comment"># 进行回溯</span></span><br></pre></td></tr></table></figure><p>下图是 commitId 形式</p><p><img src="/images/2020/04/17/commitId.png" alt="commitId"></p><h3 id="2-7-同时配置gitee-amp-github-多平台-ssh"><a href="#2-7-同时配置gitee-amp-github-多平台-ssh" class="headerlink" title="2.7  同时配置gitee&amp;github(多平台)ssh"></a>2.7  同时配置gitee&amp;github(多平台)ssh</h3><h4 id="2-7-1-本地创建多个ssh"><a href="#2-7-1-本地创建多个ssh" class="headerlink" title="2.7.1.  本地创建多个ssh"></a>2.7.1.  本地创建多个ssh</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入.ssh目录</span></span><br><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成ssh</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">"xxxx@email.com"</span> -f <span class="string">"rain_github"</span> <span class="comment"># 后续绑定github平台</span></span><br><span class="line">ssg-keygen -t rsa -C <span class="string">"xxxx@email.com"</span> -f <span class="string">"rain_gitee"</span>  <span class="comment"># 后续绑定gitee平台</span></span><br><span class="line">ssg-keygen -t rsa -C <span class="string">"xxxx@email.com"</span> -f <span class="string">"coding_id_rsa"</span>  <span class="comment"># 后续绑定coding平台</span></span><br></pre></td></tr></table></figure><p>会在本地生成如下文件</p><p><img src="/images/2020/04/17/ssh.png" alt="ssh"></p><h4 id="2-7-2-在各个平台进行ssh绑定"><a href="#2-7-2-在各个平台进行ssh绑定" class="headerlink" title="2.7.2.  在各个平台进行ssh绑定"></a>2.7.2.  在各个平台进行ssh绑定</h4><h5 id="2-7-2-1-github平台操作"><a href="#2-7-2-1-github平台操作" class="headerlink" title="2.7.2.1  github平台操作"></a>2.7.2.1  github平台操作</h5><p><img src="/images/2020/04/17/github.png" alt="github"></p><p><img src="/images/2020/04/17/githubaddssh.png" alt="githubaddssh"></p><h5 id="2-7-2-2-gitee-平台操作"><a href="#2-7-2-2-gitee-平台操作" class="headerlink" title="2.7.2.2  gitee 平台操作"></a>2.7.2.2  gitee 平台操作</h5><p><img src="/images/2020/04/17/gitee.png" alt="gitee"></p><h4 id="2-7-3-解决ssh冲突配置"><a href="#2-7-3-解决ssh冲突配置" class="headerlink" title="2.7.3.  解决ssh冲突配置"></a>2.7.3.  解决ssh冲突配置</h4><p>在 <code>C:\Users\ZHCZ\.ssh</code> 文件夹中新建 <code>config</code> 文件</p><p>进行如下配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># gitee</span></span><br><span class="line">Host gitee.com</span><br><span class="line">HostName gitee.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile C:\Users\ZHCZ\.ssh\rain_gitee</span><br><span class="line"></span><br><span class="line"><span class="comment"># github</span></span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile C:\Users\ZHCZ\.ssh\rain_github</span><br><span class="line"></span><br><span class="line"><span class="comment"># coding</span></span><br><span class="line">Host e.coding.net</span><br><span class="line">HostName e.coding.net</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile C:\Users\ZHCZ\.ssh\coding_id_rsa</span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/17/config.png" alt="config"></p><h4 id="2-7-4-测试"><a href="#2-7-4-测试" class="headerlink" title="2.7.4. 测试"></a>2.7.4. 测试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@gitee.com</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>返回success则表示设置成功</p><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="https://mp.weixin.qq.com/s/9wl8-SYspr3s358Tf0CmSg" target="_blank" rel="noopener">在 Array.reduce 中正确使用 async</a></li></ul><ul><li><p><a href="https://mp.weixin.qq.com/s/OtFsaLb2a26D0Uz4aFaoAw" target="_blank" rel="noopener">如何在 Array.filter 中正确使用 Async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/39J2KO8h_cBKg3MWB63L7w" target="_blank" rel="noopener">如何在 Array.forEach 中正确使用 Async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/mFmqyicyfaAOdxmhlPmSRQ" target="_blank" rel="noopener">如何在 Vue中优雅的使用防抖节流</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Array.reduce 中正确使用 async</title>
      <link href="/2020/04/15/async-in-Array.reduce/"/>
      <url>/2020/04/15/async-in-Array.reduce/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2020/04/15/header.png" alt="header"></p><blockquote><p>如何使用带有reduce的Promise以及如何在串行和并行处理之间进行选择 </p><p>本文译自<a href="https://advancedweb.hu/how-to-use-async-functions-with-array-reduce-in-javascript/" target="_blank" rel="noopener">How to use async functions with Array.reduce in Javascript -  <strong>Tamás Sallai</strong> </a>。 </p></blockquote><p> 在<a href="https://advancedweb.hu/asynchronous-array-functions-in-javascript/" target="_blank" rel="noopener">第一篇文章中</a>，我们介绍了async / await 如何帮助执行异步命令，但在异步处理集合时却无济于事。在本文中，我们将研究<code>reduce</code>函数，它是功能最丰富的集合函数，因为它可以模拟所有其他函数。</p><h2 id="1-Array-reduce"><a href="#1-Array-reduce" class="headerlink" title="1.  Array.reduce"></a>1.  Array.reduce</h2><p>Reduce迭代地构造一个值并返回它，它不一定是一个集合。这就是名字的来源，因为它减少了收集到的值。</p><p>迭代函数获取先前的结果（ <code>memo</code>在下面的示例中调用）以及当前值<code>e</code>。</p><p>以下函数对元素进行求和，从0开始（第二个参数<code>reduce</code>）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> syncRes = arr.reduce(<span class="function">(<span class="params">memo, e</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> memo + e;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(syncRes);</span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">memo</th><th align="center">e</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">0（初始）</td><td align="center">1个</td><td align="center">1个</td></tr><tr><td align="center">1个</td><td align="center">2</td><td align="center">3</td></tr><tr><td align="center">3</td><td align="center">3</td><td align="center">（最终结果）6</td></tr></tbody></table><p><img src="/images/2020/04/15/The-reduce-function-image.png" alt="The-reduce-function-image"></p><h2 id="2-异步-reduce"><a href="#2-异步-reduce" class="headerlink" title="2.  异步 reduce"></a>2.  异步 <code>reduce</code></h2><p>异步版本几乎相同，但每次迭代都会返回一个Promise，因此 <code>memo</code> 将是先前结果的Promise。迭代函数需要 <code>await</code> 它才能计算下一个结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// utility function for sleeping</span></span><br><span class="line"><span class="keyword">const</span> sleep = <span class="function">(<span class="params">n</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">res</span>) =&gt;</span> setTimeout(res, n));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncRes = <span class="keyword">await</span> arr.reduce(<span class="keyword">async</span> (memo, e) =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">await</span> memo) + e;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(asyncRes);</span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">memo</th><th align="center">e</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">0（初始）</td><td align="center">1</td><td align="center">Promise (1)</td></tr><tr><td align="center">Promise (1)</td><td align="center">2</td><td align="center">Promise (3)</td></tr><tr><td align="center">Promise (3)</td><td align="center">3</td><td align="center">（最终结果）Promise (6)</td></tr></tbody></table><p><img src="/images/2020/04/15/Async-reduce-function-image.png" alt="Async-reduce-function-image"></p><p>使用的结构<code>async (memo, e) =&gt; await memo</code>，<code>reduce</code>可以处理任何异步功能，并且可以对其进行<code>await</code>编辑。</p><h2 id="3-定时"><a href="#3-定时" class="headerlink" title="3.  定时"></a>3.  定时</h2><p>当在 <code>reduce</code> 中并发时有一个有趣的属性。在同步版本中，元素被一对一处理，这并不奇怪，因为它们依赖于先前的结果。但是，当异步 <code>reduce</code> 运行时，所有迭代函数将开始并行运行，<code>await memo</code>仅在需要时才等待上一个结果。</p><h3 id="3-1-await-memo-last"><a href="#3-1-await-memo-last" class="headerlink" title="3.1  await memo last"></a>3.1  await memo last</h3><p>在上面的示例中，所有 <code>sleep</code> 并行执行 ，因为<code>await memo</code>使得函数等待上一个函数完成后执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncRes = <span class="keyword">await</span> arr.reduce(<span class="keyword">async</span> (memo, e) =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">await</span> memo) + e;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Took <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime&#125;</span> ms`</span>);</span><br><span class="line"><span class="comment">// Took 11-13 ms</span></span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/15/Async-reduce-with-await-memo-last-image.png" alt="Async-reduce-with-await-memo-last-image"></p><h3 id="3-2-await-memo-first"><a href="#3-2-await-memo-first" class="headerlink" title="3.2  await memo first"></a>3.2  await memo first</h3><p>但是当<code>await memo</code>最先出现时，这些函数按顺序运行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> startTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncRes = <span class="keyword">await</span> arr.reduce(<span class="keyword">async</span> (memo, e) =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> memo;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">await</span> memo) + e;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Took <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getTime() - startTime&#125;</span> ms`</span>);</span><br><span class="line"><span class="comment">// Took 36-38 ms</span></span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/15/Async-reduce-with-await-memo-first.png" alt="Async-reduce-with-await-memo-first"></p><p>这种行为通常不是问题，这意味着不依赖于先前结果的所有内容都将立即被计算出来，只有依赖部分正在等待先前的值。</p><h3 id="3-3-当并行很重要时"><a href="#3-3-当并行很重要时" class="headerlink" title="3.3  当并行很重要时"></a>3.3  当并行很重要时</h3><p>但是在某些情况下，提前做一些事情可能是不可行的。</p><p>例如，我有一段代码可以打印不同的PDF，并使用 <code>pdf-lib</code> 库将它们拼接到一个文件中。</p><p>实现 <code>printPDF</code> 并行运行资源密集型功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> printingPages.reduce(<span class="keyword">async</span> (memo, page) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> pdf = <span class="keyword">await</span> PDFDocument.load(<span class="keyword">await</span> printPDF(page));</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pdfDoc = <span class="keyword">await</span> memo;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">await</span> pdfDoc.copyPages(pdf, pdf.getPageIndices()))</span><br><span class="line">.forEach(<span class="function">(<span class="params">page</span>) =&gt;</span> pdfDoc.addPage(page));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pdfDoc;</span><br><span class="line"></span><br><span class="line">&#125;, PDFDocument.create());</span><br></pre></td></tr></table></figure><p>我注意到当我有很多页面要打印时，它将占用过多的内存并减慢整个过程。</p><p>一个简单的更改，使 <code>printPDF</code> 调用等待上一个调用完成：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="keyword">await</span> printingPages.reduce(<span class="keyword">async</span> (memo, page) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> pdfDoc = <span class="keyword">await</span> memo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pdf = <span class="keyword">await</span> PDFDocument.load(<span class="keyword">await</span> printPDF(page));</span><br><span class="line"></span><br><span class="line">(<span class="keyword">await</span> pdfDoc.copyPages(pdf, pdf.getPageIndices()))</span><br><span class="line">.forEach(<span class="function">(<span class="params">page</span>) =&gt;</span> pdfDoc.addPage(page));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> pdfDoc;</span><br><span class="line"></span><br><span class="line">&#125;, PDFDocument.create());</span><br></pre></td></tr></table></figure><h2 id="4-结论"><a href="#4-结论" class="headerlink" title="4.  结论"></a>4.  结论</h2><p><code>reduce</code> 函数很容易转换为异步函数，但是要弄清楚并行性可能很棘手。幸运的是，它很少破坏任何东西，但是在一些资源密集型或速率受限的操作中，了解如何调用函数至关重要。</p><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><ul><li><p><a href="https://mp.weixin.qq.com/s/39J2KO8h_cBKg3MWB63L7w" target="_blank" rel="noopener">如何在 Array.forEach 中正确使用 Async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/OtFsaLb2a26D0Uz4aFaoAw" target="_blank" rel="noopener">如何在 Array.filter 中正确使用 Async</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async </tag>
            
            <tag> Array </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Array.filter 中正确使用 Async</title>
      <link href="/2020/04/13/async-in-Array.filter/"/>
      <url>/2020/04/13/async-in-Array.filter/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2020/04/13/header.png" alt=""></p><blockquote><p>本文译自<a href="https://advancedweb.hu/how-to-use-async-functions-with-array-filter-in-javascript/" target="_blank" rel="noopener">How to use async functions with Array.filter in Javascript -  <strong>Tamás Sallai</strong> </a>。 </p></blockquote><h2 id="0-如何仅保留满足异步条件的元素"><a href="#0-如何仅保留满足异步条件的元素" class="headerlink" title="0.  如何仅保留满足异步条件的元素"></a>0.  如何仅保留满足异步条件的元素</h2><p>在<a href="https://advancedweb.hu/asynchronous-array-functions-in-javascript/" target="_blank" rel="noopener">第一篇文章中</a>，我们介绍了 async / await 如何帮助处理异步事件，但在异步处理集合时却无济于事。在本文中，我们将研究该<code>filter</code>函数，它可能是支持异步函数的最直观的方法。</p><h2 id="1-Array-filter"><a href="#1-Array-filter" class="headerlink" title="1.  Array.filter"></a>1.  Array.filter</h2><p>该<code>filter</code>函数仅保留通过条件的元素。它得到一个断言( <em>predicate</em> )函数，并且此函数返回 true / false 值。结果集合仅包含断言( <em>predicate</em> )返回 true 的元素。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> syncRes = arr.filter(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> i % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(syncRes);</span><br><span class="line"><span class="comment">// 2,4</span></span><br></pre></td></tr></table></figure><h2 id="2-filter-结合-map-使用"><a href="#2-filter-结合-map-使用" class="headerlink" title="2.  filter 结合 map 使用"></a>2.  filter 结合 map 使用</h2><p>这次的异步版本要复杂一些，它分为两个阶段。第一个通过断言函数异步地映射数组，从而生成true / false 值。然后第二步是利用第一步的结果同步 <code>filter</code></p><p><img src="/images/2020/04/13/Async-filter.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncFilter = <span class="keyword">async</span> (arr, predicate) =&gt; &#123;</span><br><span class="line"><span class="keyword">const</span> results = <span class="keyword">await</span> <span class="built_in">Promise</span>.all(arr.map(predicate));</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> arr.filter(<span class="function">(<span class="params">_v, index</span>) =&gt;</span> results[index]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> asyncRes = <span class="keyword">await</span> asyncFilter(arr, <span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line"><span class="keyword">await</span> sleep(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">return</span> i % <span class="number">2</span> === <span class="number">0</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(asyncRes);</span><br><span class="line"><span class="comment">// 2,4</span></span><br></pre></td></tr></table></figure><p>或单行实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> asyncFilter = <span class="keyword">async</span> (arr, predicate) =&gt; <span class="built_in">Promise</span>.all(arr.map(predicate))</span><br><span class="line">.then(<span class="function">(<span class="params">results</span>) =&gt;</span> arr.filter(<span class="function">(<span class="params">_v, index</span>) =&gt;</span> results[index]));</span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/13/Async-filter-with-map.png" alt=""></p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>上面的实现同时运行所有断言函数。通常，这很好，但是与所有其他功能一样，它可能会使某些资源变得过分紧张。幸运的是，由于上述实现依赖于此 <code>map</code>，<a href="https://advancedweb.hu/how-to-use-async-functions-with-array-map-in-javascript/" target="_blank" rel="noopener">因此可以使用相同的并发控件</a>。</p><h2 id="4-filter-结合-reduce-使用"><a href="#4-filter-结合-reduce-使用" class="headerlink" title="4.  filter 结合 reduce 使用"></a>4.  filter 结合 reduce 使用</h2><p>除了使用异步 <code>map</code> 与同步之外 <code>filter</code> ，异步 <code>reduce</code>  <a href="https://advancedweb.hu/how-to-use-async-functions-with-array-reduce-in-javascript/" target="_blank" rel="noopener">也可以完成这项工作</a>。由于它只是一个功能，因此即使没有提供相同级别的控制，结构也更加容易。</p><p>首先，从一个空数组（<code>[]</code>）开始。然后通过断言函数运行下一个元素，如果通过则将其追加到数组。如果没有，请跳过它。</p><p><img src="/images/2020/04/13/Async-filter-with-reduce.png" alt=""></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// concurrently</span></span><br><span class="line"><span class="keyword">const</span> asyncFilter = <span class="keyword">async</span> (arr, predicate) =&gt; </span><br><span class="line">arr.reduce(<span class="keyword">async</span> (memo, e) =&gt;</span><br><span class="line"><span class="keyword">await</span> predicate(e) ? [...await memo, e] : memo</span><br><span class="line">, []);</span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/13/Async-filter-with-reduce2.png" alt=""></p><p>请注意，<code>await predicate(e)</code> 在 <code>await memo</code> 之前，这意味着这些将并行调用。</p><h3 id="顺序处理"><a href="#顺序处理" class="headerlink" title="顺序处理"></a>顺序处理</h3><p>要在调用下一个谓词函数之前等待其结束，请更改 <code>await</code>  的顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sequentially</span></span><br><span class="line"><span class="keyword">const</span> asyncFilter = <span class="keyword">async</span> (arr, predicate) =&gt; </span><br><span class="line">arr.reduce(<span class="keyword">async</span> (memo, e) =&gt; </span><br><span class="line">[...await memo, ...await predicate(e) ? [e] : []]</span><br><span class="line">, []);</span><br></pre></td></tr></table></figure><p>此实现等待上一个元素，然后根据断言（<code>...[e]</code>或<code>...[]</code>）的结果有条件地附加一个元素。</p><p><img src="/images/2020/04/13/Async-filter-with-reduce-running-sequentially.png" alt=""></p><h2 id="5-结论"><a href="#5-结论" class="headerlink" title="5.  结论"></a>5.  结论</h2><p>虽然异步<code>filter</code>是可能的，但它最初的工作方式看起来很奇怪。尽管并发控制仍然可用，但与其他异步功能相比，它们需要更多的计划去控制它。</p><h4 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h4><ul><li><p><a href="https://mp.weixin.qq.com/s/39J2KO8h_cBKg3MWB63L7w" target="_blank" rel="noopener">如何在 Array.forEach 中正确使用 Async</a></p></li><li><p><a href="https://mp.weixin.qq.com/s/mFmqyicyfaAOdxmhlPmSRQ" target="_blank" rel="noopener">如何在 Vue中优雅的使用防抖节流</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async </tag>
            
            <tag> Array </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 Array.forEach 中正确使用 Async</title>
      <link href="/2020/04/10/async-in-Array.forEach/"/>
      <url>/2020/04/10/async-in-Array.forEach/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文译自<a href="https://advancedweb.hu/how-to-use-async-functions-with-array-foreach-in-javascript/" target="_blank" rel="noopener">How to use async functions with Array.forEach in Javascript - <strong>Tamás Sallai</strong> </a>。</p></blockquote><h2 id="0-如何异步遍历元素"><a href="#0-如何异步遍历元素" class="headerlink" title="0. 如何异步遍历元素"></a>0. 如何异步遍历元素</h2><p>在<a href="https://advancedweb.hu/asynchronous-array-functions-in-javascript/" target="_blank" rel="noopener">第一篇文章中</a>，我们介绍了 async / await 如何帮助处理异步事件，但在异步处理集合时却无济于事。在本文中，我们将研究该<code>forEach</code>功能，当您需要为集合中的每个元素运行一段代码时，该功能将非常有用。</p><h2 id="1-forEach"><a href="#1-forEach" class="headerlink" title="1. forEach"></a>1. <code>forEach</code></h2><p>该<code>forEach</code>函数类似于<code>map</code>，但是它不转换值并使用结果，而是为每个元素运行该函数并丢弃结果（这里可以理解成是否有<code>return</code>值）。实际上，重要的部分是调用函数的副作用。</p><p>例如，将每个元素同步打印到控制台：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function">(<span class="params">i</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Finished sync"</span>);</span><br><span class="line"><span class="comment">// Finished sync</span></span><br></pre></td></tr></table></figure><p>由于结果并不重要，因此可以使用异步函数作为迭代器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line">  <span class="comment">// each element takes a different amount of time to complete</span></span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">10</span> - i);</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Finished async"</span>);</span><br><span class="line"><span class="comment">// Finished async</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/10/forEach.png" alt="forEach"></p><h2 id="2-控制时间"><a href="#2-控制时间" class="headerlink" title="2. 控制时间"></a>2. 控制时间</h2><h3 id="2-1-等待完成"><a href="#2-1-等待完成" class="headerlink" title="2.1 等待完成"></a>2.1 等待完成</h3><p>但是，并不奇怪，该函数被<strong>异步</strong>调用，并且程序执行超出了调用范围。这是与同步版本的重要区别，因为在执行下一行时，同步<code>forEach</code>已经完成，而异步版本尚未完成。这就是为什么“完成的异步”日志出现在元素之前的原因。</p><p>要在继续进行之前等待所有函数调用完成，可以使用带有<code>Promise.all</code>的<code>map</code>，并丢弃结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">  arr.map(<span class="keyword">async</span> (i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">await</span> sleep(<span class="number">10</span> - i);</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Finished async"</span>);</span><br><span class="line"><span class="comment">// Finished async</span></span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/10/map.png" alt="map"></p><p>进行此更改后，“完成的异步操作”排在最后。</p><h3 id="2-2-顺序处理"><a href="#2-2-顺序处理" class="headerlink" title="2.2 顺序处理"></a>2.2 顺序处理</h3><p>但是请注意，迭代函数是并行调用的。要忠实地遵循同步<code>forEach</code>，要先使用带<code>await memo</code>的<code>reduce</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> arr.reduce(<span class="keyword">async</span> (memo, i) =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> memo;</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">10</span> - i);</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;, <span class="literal">undefined</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"Finished async"</span>);</span><br><span class="line"><span class="comment">// Finished async</span></span><br></pre></td></tr></table></figure><p><img src="/images/2020/04/10/reduce.png" alt="reduce"></p><p>这样，元素依次依次处理，程序执行将等待整个数组完成后再继续。</p><h2 id="3-结论"><a href="#3-结论" class="headerlink" title="3. 结论"></a>3. 结论</h2><p>异步<code>forEach</code>易于使用，但是是否应使用<code>forEach</code>，<code>map</code>或 <code>reduce</code>取决于计时的要求。如果您只想在任何时候运行这些功能，请使用<code>forEach</code>。如果要确保继续操作之前完成操作，请使用<code>map</code>。最后，如果您需要一个一个地运行它们，请使用<code>reduce</code>。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> async </tag>
            
            <tag> Array </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在Vue中优雅的使用防抖节流</title>
      <link href="/2020/04/09/vue-debounce-throttle/"/>
      <url>/2020/04/09/vue-debounce-throttle/</url>
      
        <content type="html"><![CDATA[<h2 id="1-什么是防抖节流"><a href="#1-什么是防抖节流" class="headerlink" title="1. 什么是防抖节流"></a>1. 什么是防抖节流</h2><h4 id="防抖：防止重复点击触发事件"><a href="#防抖：防止重复点击触发事件" class="headerlink" title="防抖：防止重复点击触发事件"></a>防抖：防止重复点击触发事件</h4><p>首先啥是抖？ 抖就是一哆嗦！原本点一下，现在点了 3 下！不知道老铁脑子是不是很有画面感！哈哈哈哈哈哈</p><p>典型应用就是防止用户多次重复点击请求数据。</p><p>代码实现要点：设置一个定时器，通过闭包，抓住定时器变量，控制定时器的添加和清除</p><p>直接上代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="keyword">this</span>, _arguments);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="节流：指定时间间隔内只会执行一次任务"><a href="#节流：指定时间间隔内只会执行一次任务" class="headerlink" title="节流：指定时间间隔内只会执行一次任务"></a>节流：指定时间间隔内只会执行一次任务</h4><p>大家都玩过 FPS 游戏吧（没玩过？？？打枪知道了吧！）道具的射速是一定的，不会因为你点击鼠标的速度加快而增加。</p><p>代码实现要点：通过一个布尔变量作为状态，判断代码是否需要执行</p><p>直接上代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _arguments = <span class="built_in">arguments</span>;</span><br><span class="line">  <span class="keyword">let</span> canRun = <span class="literal">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span>;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="keyword">this</span>, _arguments);</span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-在-Vue-中优雅的使用"><a href="#2-在-Vue-中优雅的使用" class="headerlink" title="2. 在 Vue 中优雅的使用"></a>2. 在 Vue 中优雅的使用</h2><p>我的应用场景：头像裁剪组件，对滚轮缩放后生成预览图片进行防抖处理</p><p><img src="/images/2020/04/09/touxiang.gif" alt="场景"></p><p>因为 Vue 组件中的 <code>this</code> 原因</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">  previewImageDebounce: Debounce(<span class="keyword">this</span>.previewImage, <span class="number">1000</span>),</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//报错 Uncaught TypeError: Cannot read property 'previewImage' of undefined</span></span><br></pre></td></tr></table></figure><p>我们要针对上面的防抖函数进行改造（函数内容 this 指向没问题，我们通过函数名调用函数）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  description: 在vue中使用的防抖函数</span></span><br><span class="line"><span class="comment"> *  param fnName &#123;String&#125;  函数名</span></span><br><span class="line"><span class="comment"> *  param time &#123;Number&#125;    延迟时间</span></span><br><span class="line"><span class="comment"> *  return: 处理后的执行函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">VueDebounce</span>(<span class="params">fnName, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">      clearTimeout(timeout);</span><br><span class="line">    &#125;</span><br><span class="line">    timeout = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>[fnName]();</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Vue 组件中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">methods:&#123;</span><br><span class="line">    <span class="comment">/* 监听滚轮滑动 */</span></span><br><span class="line">  Wheel(ev) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.newImage) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 判断放大和缩小</span></span><br><span class="line">    ev.deltaY &gt; <span class="number">0</span> ? <span class="keyword">this</span>.makeScaleChange(<span class="number">1</span>) : <span class="keyword">this</span>.makeScaleChange(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 预览图片</span></span><br><span class="line">    <span class="keyword">this</span>.previewImageDebounce();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">/* 预览图片(防抖处理后) */</span></span><br><span class="line">  previewImageDebounce: VueDebounce(<span class="string">"previewImage"</span>, <span class="number">1000</span>),</span><br><span class="line">  <span class="comment">/* 预览图片 */</span></span><br><span class="line">  previewImage() &#123;......&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的写法，算是很优雅了。节流就不在这里展开了，开动你的小脑袋不成问题。</p>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一道“简单”的 This 题解析</title>
      <link href="/2020/04/07/a-simple-this-question/"/>
      <url>/2020/04/07/a-simple-this-question/</url>
      
        <content type="html"><![CDATA[<h2 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1. 知识点"></a>1. 知识点</h2><p>匿名函数无法从函数内部应用自身</p><p>this 是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this 的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。</p><p>当一个函数被调用时，会创建一个活动记录(有时候也称为执行上下文)。这个记录会包含函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this 就是记录的其中一个属性，会在函数执行的过程中用到。</p><p>this 简单讲就是：调用我的”人”在什么上下文环境，我就指向谁！！</p><h2 id="2-题目："><a href="#2-题目：" class="headerlink" title="2. 题目："></a>2. 题目：</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  number: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">    number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(num);</span><br><span class="line">      number *= <span class="number">3</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(number);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  db2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn1 = obj.fn1;</span><br><span class="line"><span class="keyword">var</span> fn2 = obj.db2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(number);</span><br><span class="line"></span><br><span class="line">fn1();</span><br><span class="line">fn2();</span><br><span class="line"></span><br><span class="line">obj.fn1();</span><br><span class="line">obj.db2();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.number);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(obj.number);</span><br></pre></td></tr></table></figure><h2 id="3-执行过程"><a href="#3-执行过程" class="headerlink" title="3. 执行过程"></a>3. 执行过程</h2><h4 id="var-fn1-obj-fn1"><a href="#var-fn1-obj-fn1" class="headerlink" title="var fn1 = obj.fn1;"></a><code>var fn1 = obj.fn1;</code></h4><p><code>fn1</code>在全局执行，this 指向全局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  number: <span class="number">4</span>,</span><br><span class="line">  fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>; <span class="comment">// 指向全局变量number number=4</span></span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">    number = <span class="number">3</span>; <span class="comment">// 函数内number = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(num);</span><br><span class="line">      number *= <span class="number">3</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(number);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  db2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="var-fn2-obj-db2"><a href="#var-fn2-obj-db2" class="headerlink" title="var fn2 = obj.db2;"></a><code>var fn2 = obj.db2;</code></h4><p><code>fn2</code> 中的 this 指向全局变量</p><h4 id="console-log-number"><a href="#console-log-number" class="headerlink" title="console.log(number)"></a><code>console.log(number)</code></h4><p>打印全局变量 number</p><p>输出 ‘4’</p><h4 id="fn1"><a href="#fn1" class="headerlink" title="fn1()"></a><code>fn1()</code></h4><p>this 指向全局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  number: <span class="number">4</span>,</span><br><span class="line">  fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>; <span class="comment">//全局number=4</span></span><br><span class="line">    number = number * <span class="number">2</span>; <span class="comment">//NAN</span></span><br><span class="line">    number = <span class="number">3</span>; <span class="comment">//函数内number = 3</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="keyword">this</span>.number; <span class="comment">//全局作用域 num=4</span></span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>; <span class="comment">// 全局number = 8</span></span><br><span class="line">      <span class="built_in">console</span>.log(num); <span class="comment">// 输出4</span></span><br><span class="line">      number *= <span class="number">3</span>; <span class="comment">// 函数内number 3*3=9(形成闭包)</span></span><br><span class="line">      <span class="built_in">console</span>.log(number); <span class="comment">// 输出9</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  db2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="fn2"><a href="#fn2" class="headerlink" title="fn2()"></a><code>fn2()</code></h4><p>this 指向全局</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  number: <span class="number">4</span>,</span><br><span class="line">  fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">    number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(num);</span><br><span class="line">      number *= <span class="number">3</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(number);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  db2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>; <span class="comment">//全局number = 8   8*2=16</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="obj-fn1"><a href="#obj-fn1" class="headerlink" title="obj.fn1()"></a><code>obj.fn1()</code></h4><p>这里执行时 执行环境是 obj，所以 this 指向 obj</p><p><code>this.number = obj.number</code></p><p>number 则是形成闭包，调用上次的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  number: <span class="number">4</span>,</span><br><span class="line">  fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">    number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="keyword">this</span>.number; <span class="comment">// obj.number=this.number=num=4</span></span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>; <span class="comment">// obj.number =4*2=8</span></span><br><span class="line">      <span class="built_in">console</span>.log(num); <span class="comment">// 打印 num=4</span></span><br><span class="line">      number *= <span class="number">3</span>; <span class="comment">//闭包 number=9*3=27</span></span><br><span class="line">      <span class="built_in">console</span>.log(number); <span class="comment">// 打印 number=27</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  db2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="obj-db2"><a href="#obj-db2" class="headerlink" title="obj.db2()"></a><code>obj.db2()</code></h4><p><code>this</code> 指向<code>obj</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  number: <span class="number">4</span>,</span><br><span class="line">  fn1: (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> number;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">    number = number * <span class="number">2</span>;</span><br><span class="line">    number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> num = <span class="keyword">this</span>.number;</span><br><span class="line">      <span class="keyword">this</span>.number *= <span class="number">2</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(num);</span><br><span class="line">      number *= <span class="number">3</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(number);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;)(),</span><br><span class="line">  db2: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.number *= <span class="number">2</span>; <span class="comment">// obj.number=this.number=8*2=16</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="console-log-window-number"><a href="#console-log-window-number" class="headerlink" title="console.log(window.number)"></a><code>console.log(window.number)</code></h4><p>打印 16</p><h4 id="console-log-obj-number"><a href="#console-log-obj-number" class="headerlink" title="console.log(obj.number)"></a><code>console.log(obj.number)</code></h4><p>打印 16</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><p><a href="https://juejin.im/post/5da7cdff6fb9a04de7735742" target="_blank" rel="noopener">【THE LAST TIME】this：call、apply、bind</a></p></li><li><p>你不知道的 JavaSctript（上卷）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> this </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nuxt.js 究极按需引入 ant design vue</title>
      <link href="/2020/04/06/need-load-antdvue-in-muxt/"/>
      <url>/2020/04/06/need-load-antdvue-in-muxt/</url>
      
        <content type="html"><![CDATA[<p><img src="/images/2020/04/06/nuxtimg.jpg" alt="header"></p><p>在网络上看了很多ui组件按需加载的案例，但是那不是我想要的</p><h2 id="1-首先我们看一下-错误的示范！！"><a href="#1-首先我们看一下-错误的示范！！" class="headerlink" title="1. 首先我们看一下 错误的示范！！"></a>1. 首先我们看一下 错误的示范！！</h2><p>1.1.配置插件 plugins\antd-ui.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'ant-design-vue/lib/button'</span></span><br><span class="line"><span class="keyword">import</span> Steps <span class="keyword">from</span> <span class="string">'ant-design-vue/lib/steps'</span></span><br><span class="line"><span class="keyword">import</span> Form <span class="keyword">from</span> <span class="string">'ant-design-vue/lib/form'</span></span><br><span class="line"><span class="keyword">import</span> Input <span class="keyword">from</span> <span class="string">'ant-design-vue/lib/input'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Button)</span><br><span class="line">Vue.use(Steps) <span class="comment">// 步骤条</span></span><br><span class="line">Vue.use(Form)</span><br><span class="line">Vue.use(Form.Item)</span><br><span class="line">Vue.use(Input)</span><br></pre></td></tr></table></figure><p>1.2.引入css样式 nuxt.config.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># nuxt.config.js</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  css: [</span><br><span class="line">    <span class="string">'./style/basic.less'</span></span><br><span class="line">    <span class="string">'ant-design-vue/lib/button/style/index.css'</span>,</span><br><span class="line">    <span class="string">'ant-design-vue/lib/steps/style/index.css'</span>,</span><br><span class="line">    <span class="string">'ant-design-vue/lib/form/style/index.css'</span>,</span><br><span class="line">    <span class="string">'ant-design-vue/lib/input/style/index.css'</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  plugins: [&#123; <span class="attr">src</span>: <span class="string">'@/plugins/antd-ui'</span>, <span class="attr">ssr</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不知道大家看出错什么问题</p><p><strong>我们去官方文档中寻找一点线索</strong></p><p><img src="/images/2020/04/06/css.png" alt="nuxt css1"></p><p><strong>重点来喽！！！！！</strong></p><p><img src="/images/2020/04/06/css2.png" alt="nuxt css2"></p><p>css引入的样式是全局样式！！！如果这里是SPA，我觉着这OK，但是我们是SSR，需要进一步的优化</p><h2 id="2-真正的按需加载"><a href="#2-真正的按需加载" class="headerlink" title="2.  真正的按需加载"></a>2.  真正的按需加载</h2><p>我们抛弃在全局样式中进行加载，在组件中引用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div &gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import &#39;@&#x2F;node_modules&#x2F;ant-design-vue&#x2F;lib&#x2F;button&#x2F;style&#x2F;index.css&#39;</span><br><span class="line">import &#39;@&#x2F;node_modules&#x2F;ant-design-vue&#x2F;lib&#x2F;steps&#x2F;style&#x2F;index.css&#39;</span><br><span class="line">import &#39;@&#x2F;node_modules&#x2F;ant-design-vue&#x2F;lib&#x2F;form&#x2F;style&#x2F;index.css&#39;</span><br><span class="line">import &#39;@&#x2F;node_modules&#x2F;ant-design-vue&#x2F;lib&#x2F;input&#x2F;style&#x2F;index.css&#39;</span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;style&gt;</span><br></pre></td></tr></table></figure><p>虽然这样或许不是很优雅，但是这才是真正意义上的 SSR 按需加载 UI 组件</p>]]></content>
      
      
      <categories>
          
          <category> Nuxt </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nuxt </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
